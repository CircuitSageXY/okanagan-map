<!doctype html>
<html>
<head>
<meta charset="utf-8">                   
<title>Okanagan Route Planner</title>

<link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap">

<style>
/* ---------- GLOBAL VARIABLES ---------- */
:root{
  --clrA:#4285F4; --clrB:#0F9D58; --clrC:#F4B400; --clrD:#DB4437;
  --clrE:#ab47bc; --clrF:#00acc1; --clrG:#ff7043; --clrH:#8d6e63;
  --clrDefault:#607d8b;

  --clrPanelBg:#ffffff; --clrPanelBorder:#d7d7d7; --clrPanelStripe:#2196f3;
  --clrPanelShadow:0 2px 8px rgba(0,0,0,.25);
  --clrInputBorder:#c7c7c7; --clrInputBg:#fff; --clrInputBgAlt:#fafafa;

  --radiusSm:4px; --radiusMd:6px; --radiusLg:10px;
  --transFast:.12s; --fontMain:Roboto,Arial,sans-serif;

  --f-early:#8BC34A; --f-late:#4CAF50; --f-lunch:#FFEB3B;
  --f-afternoon:#03A9F4; --f-supper:#FF9800;
  --f-evening:#BA68C8; --f-lateev:#F44336;

  --panelW:480px;
  --tlW:74px;
  --axis-w:4px;
  --tick-minor:#9e9e9e; --tick-major:#424242;

  --pxPerMin:2;

  /* Label palette (map-tuned) */
  --accent-teal:#2A9D8F;
  --accent-blue:#3B82F6;
  --accent-slate:#475569;
  --accent-olive:#6B8E23;

  --label-paper:#ffffff;
  --label-ink:#0f1720;
  --label-border:rgba(15,23,32,.14);
  --label-halo:rgba(15,23,32,.16);
}

/* ---------- BASICS ---------- */
html,body,#map{height:100%;margin:0;font-family:var(--fontMain);}
#map{backface-visibility:hidden;transform:translateZ(0);}
.hidden{display:none!important;}
.pac-container{ display:none !important; }  /* hide Google popup (we render our own) */

/* ---------- LEFT SIDE PANEL ---------- */
#panel{
  position:absolute;top:0;left:0;z-index:5;width:var(--panelW);height:100%;
  background:var(--clrPanelBg);border-right:1px solid var(--clrPanelBorder);
  box-shadow:var(--clrPanelShadow);border-top-right-radius:var(--radiusLg);
  border-bottom-right-radius:var(--radiusLg);display:flex;flex-direction:column;
}
#scroller{flex:1;overflow:auto;position:relative;padding:12px 12px 8px 0;}
#content{display:flex;align-items:flex-start;position:relative;}
#timelineCol{display:none;} #timeline{display:none;}

/* ---------- FRAMES ---------- */
#framesContainer{flex:1;min-width:0;}
.frame{
  border:1px solid var(--clrPanelBorder);border-radius:6px;margin-bottom:14px;background:#fff;
  box-shadow:0 1px 2px rgba(0,0,0,.08);position:relative;display:flex;flex-direction:column;
}
.frame-header{
  position:relative;top:auto;z-index:1;display:flex;align-items:center;gap:8px;padding:6px 10px;
  font-size:15px;font-weight:500;color:#000;border-bottom:1px solid #e0e0e0;background:#fafafa;
}
.frame-header .swatch{width:16px;height:16px;border-radius:3px;flex:none;}
.frame-hide{margin-left:auto;cursor:pointer;color:#666;font-size:20px;line-height:20px;}
.frame-hide:hover{color:#000;}
.frame.collapsed .frame-body,.frame.collapsed .addRowBtn{display:none;}
.frame.collapsed{opacity:.55;}
.frame.collapsed .frame-hide{color:#c00;}

.frame-body{
  display:grid;grid-template-columns: var(--tlW) 1fr;column-gap:12px;
  align-items:stretch; padding:6px 10px 8px 6px;
}
.frame-timeline{position:relative;}
.tl-axis{position:absolute;left:6px;width:var(--axis-w);background:#000;border-radius:2px;}
.tl-tick{position:absolute;left:0;width:100%;pointer-events:none;}
.tl-tick::before{content:"";position:absolute;left:calc(6px + var(--axis-w));width:6px;height:1px;background:var(--tick-minor);}
.tl-tick.bold::before{width:10px;background:var(--tick-major);}
.tl-label{position:absolute;left:18px;font-size:11px;color:#424242;background:rgba(255,255,255,.85);
  padding:0 2px;border-radius:2px;line-height:1;}
.nowMarker{
  position:absolute;left:calc(6px + var(--axis-w)/2);width:12px;height:12px;border:2px solid #000;background:#fff;border-radius:50%;
  transform:translate(-50%,-50%);box-shadow:0 0 4px rgba(0,0,0,.4);animation:pulse 2s infinite;z-index:3;}
@keyframes pulse{0%{box-shadow:0 0 0 0 rgba(0,0,0,.35);}70%{box-shadow:0 0 0 6px rgba(0,0,0,0);}100%{box-shadow:0 0 0 0 rgba(0,0,0,0);}}

/* shaded band */
.tl-seg{position:absolute;left:0;right:0;border-radius:3px;opacity:.08;}
.frame-list{overflow:visible;flex:1 1 auto;}
.addRowBtn{display:none;}

/* colored borders per frame */
.frame[data-frame="0"]{border-left:4px solid var(--f-early);}
.frame[data-frame="1"]{border-left:4px solid var(--f-late);}
.frame[data-frame="2"]{border-left:4px solid var(--f-lunch);}
.frame[data-frame="3"]{border-left:4px solid var(--f-afternoon);}
.frame[data-frame="4"]{border-left:4px solid var(--f-afternoon);}
.frame[data-frame="5"]{border-left:4px solid var(--f-supper);}
.frame[data-frame="6"]{border-left:4px solid var(--f-evening);}
.frame[data-frame="7"]{border-left:4px solid var(--f-lateev);}

/* ---------- ROWS ---------- */
.row{display:flex;align-items:center;margin:8px 0;padding:4px 6px 4px 0;border-radius:var(--radiusMd);transition:background var(--transFast),box-shadow var(--transFast),outline var(--transFast);}
.row.focused{background:var(--clrInputBgAlt);box-shadow:0 0 0 2px rgba(33,150,243,.25);}
.row:hover:not(.focused):not(.selected){background:rgba(0,0,0,.04);}
.row.invalid input.stop{border-color:#e53935;background:#fff7f7;}
.row.selected{outline:3px solid rgba(33,150,243,.6);}

.bullet{
  min-width:24px;padding:0 6px;height:24px;border-radius:50%;
  line-height:24px;text-align:center;font-weight:600;font-size:13px;color:#fff;
  margin-right:8px;flex:none;box-shadow:0 0 0 2px rgba(255,255,255,.8),0 0 4px rgba(0,0,0,.35);}
.A{background:var(--clrA)} .B{background:var(--clrB)}
.C{background:var(--clrC)} .D{background:var(--clrD)}
.E{background:var(--clrE)} .F{background:var(--clrF)}
.G{background:var(--clrG)} .H{background:var(--clrH)}
.defaultBullet{background:var(--clrDefault)}

  /* locked-row badge */
.row.locked .bullet{
  position: relative;
}
.row.locked .bullet::after{
  content: "🔒";
  position: absolute;
  top: -6px;              /* adjust if you want it higher/lower */
  right: -6px;
  width: 16px;
  height: 16px;
  font-size: 12px;
  line-height: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: #c62828;    /* red bubble */
  color: #fff;
  box-shadow: 0 0 0 2px #fff;
}

input.stop{
  flex:1;height:38px;border:1px solid var(--clrInputBorder);
  border-radius:var(--radiusSm);padding:4px 6px 4px 10px;font-size:14px;
  background:var(--clrInputBg);transition:border-color var(--transFast),box-shadow var(--transFast);}
input.stop:focus{outline:none;border-color:var(--clrPanelStripe);box-shadow:0 0 0 3px rgba(33,150,243,.25);}
.row[data-frame="0"] input.stop{border-left:4px solid var(--f-early);    padding-left:6px;}
.row[data-frame="1"] input.stop{border-left:4px solid var(--f-late);     padding-left:6px;}
.row[data-frame="2"] input.stop{border-left:4px solid var(--f-lunch);    padding-left:6px;}
.row[data-frame="3"] input.stop{border-left:4px solid var(--f-afternoon);padding-left:6px;}
.row[data-frame="4"] input.stop{border-left:4px solid var(--f-afternoon);padding-left:6px;}
.row[data-frame="5"] input.stop{border-left:4px solid var(--f-supper);   padding-left:6px;}
.row[data-frame="6"] input.stop{border-left:4px solid var(--f-evening);  padding-left:6px;}
.row[data-frame="7"] input.stop{border-left:4px solid var(--f-lateev);   padding-left:6px;}

.drag{cursor:grab;margin-left:6px;color:#666;font-size:22px;line-height:22px;padding:2px;border-radius:var(--radiusSm);}
.drag:hover{background:rgba(0,0,0,.08);} .drag:active{cursor:grabbing;}
.remove{
  cursor:pointer;margin-left:4px;font-size:20px;line-height:20px;color:#fff;
  width:22px;height:22px;display:inline-flex;align-items:center;justify-content:center;
  background:var(--clrD);border-radius:var(--radiusSm);
  transition:transform var(--transFast),background var(--transFast);}
.remove:hover{background:#f75a4d;transform:scale(1.08);} .remove:active{transform:scale(.94);}

/* ---------- TOTALS ---------- */
#msg{
  position:sticky; bottom:0;margin:0; padding:8px 12px 10px 12px;
  color:#0b63c7;font-weight:700;font-size:16px;
  background:linear-gradient(to bottom, rgba(240,248,255,.6), rgba(240,248,255,.95));
  border-top:1px solid #d7d7d7; backdrop-filter:blur(2px);
}

/* ---------- FLAT MODE ---------- */
#panel.flat{width:auto;background:transparent;border:none;box-shadow:none;pointer-events:none;}
#panel.flat #content{display:none;}
#panel.flat #scroller{padding:12px;}
#panel.flat #msg{display:none;}

#addrBar{
  position:absolute;top:12px;left:12px;width:380px;z-index:8;
  background:rgba(255,255,255,.75);border:1px solid #d7d7d7;border-radius:10px;
  box-shadow:0 2px 6px rgba(0,0,0,.25);padding:12px 12px 10px 12px;
  pointer-events:auto;display:none;backdrop-filter:blur(2px);}
#addrBar.active{display:block;}
#addrBarHeader{display:flex;align-items:center;gap:8px;margin-bottom:6px;font-weight:500;font-size:15px;}
#addrTitle{flex:1;}
#addrToggles{display:flex;gap:6px;}
.toggleChip{
  padding:3px 10px;border-radius:14px;border:1px solid #bbb;font-size:12px;cursor:pointer;user-select:none;line-height:16px;display:inline-block;min-width:46px;text-align:center;
  transition: background var(--transFast), color var(--transFast), border-color var(--transFast), box-shadow var(--transFast);
}
.toggleChip.day  {border-color:var(--f-afternoon);color:var(--f-afternoon);}
.toggleChip.night{border-color:var(--f-evening);color:var(--f-evening);}
.toggleChip.active.day  {background:var(--f-afternoon);color:#fff;}
.toggleChip.active.night{background:var(--f-evening);color:#fff;}
.toggleChip.day:hover,.toggleChip.day:focus-visible{background:var(--f-afternoon);color:#fff;}
.toggleChip.night:hover,.toggleChip.night:focus-visible{background:var(--f-evening);color:#fff;}

#addrAdd{display:none;}
#addrList .row{margin:6px 0;}
#addrFooter{margin-top:10px;border-top:1px solid #dadada;padding-top:8px;display:flex;align-items:center;gap:8px;flex-wrap:wrap;}
#flatMsg{font-size:16px;font-weight:700;color:#0066cc;flex:1 1 100%;}
#flatButtons{display:flex;gap:6px;align-items:center;}
#flatButtons .toggleChip{ padding:4px 12px; line-height:20px; min-width:auto; }
#flatButtons .toggleChip.action{ border-color:var(--clrB); color:var(--clrB); }
#flatButtons .toggleChip.action:hover,
#flatButtons .toggleChip.action.active{ background:var(--clrB); color:#fff; }
#flatDelSel{background:#db4437;color:#fff;display:none;padding:6px 12px;border-radius:6px;border:none;cursor:pointer;}

/* ---------- OUR suggestion dropdown ---------- */
.sg{
  position:absolute; z-index:9999; background:#fff; border:1px solid #d2d2d2;
  border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,.15); overflow:auto; max-height:220px; display:none; min-width:260px;
}
.sg ul{list-style:none;margin:0;padding:4px 0;}
.sg li{padding:8px 12px;cursor:pointer;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-size:13px;}
.sg li:hover,.sg li.active{background:#e8f1fe;}
.sg small{opacity:.7;margin-left:6px;}

/* ===========================================================
   LABEL OVERLAY (capsule)
   =========================================================== */
.region-label{
  position:absolute; left:0; top:0; transform:translate(-50%,-100%) scale(.96); opacity:0;
  will-change:transform,opacity; z-index:1000; pointer-events:auto;
}
.badge{
  position:relative; display:flex; align-items:center; gap:10px; padding:6px 10px;
  background:var(--label-paper); color:var(--label-ink); border:1px solid var(--label-border);
  border-radius:16px; box-shadow:0 2px 8px rgba(0,0,0,.10);
}
.badge::before{content:""; position:absolute; inset:-14px -18px -18px -18px; z-index:-1;
  background:radial-gradient(140px 70px at 50% 60%, var(--label-halo), transparent 65%);}
.badge::after{content:""; position:absolute; left:calc(50% - 8px); bottom:-8px; width:0;height:0;
  border-left:8px solid transparent;border-right:8px solid transparent;border-top:8px solid var(--label-paper);
  filter:drop-shadow(0 1px 1px rgba(0,0,0,.10));}
.accent{ width:8px; height:22px; border-radius:4px; flex:none; background:var(--accent,#2A9D8F);
  box-shadow:inset 0 0 0 1px rgba(255,255,255,.5), 0 0 0 1px rgba(0,0,0,.05); }
.titlewrap{ display:inline-block; padding:3px 10px; border-radius:12px;
  background: color-mix(in srgb, var(--accent) 16%, #fff);
  border:1px solid color-mix(in srgb, var(--accent) 55%, transparent);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.6); }
.title{ font-weight:800; letter-spacing:.35px; text-transform:uppercase; white-space:nowrap; font-size:14px; }
.close{ margin-left:6px; width:22px; height:22px; border-radius:50%; display:inline-flex; align-items:center; justify-content:center;
  background:#fff; border:1px solid var(--label-border); box-shadow:0 1px 1px rgba(0,0,0,.06); color:#4b5563; font-size:16px; line-height:16px; cursor:pointer; }
.close:hover{ color:#000; }

@media (prefers-reduced-motion: reduce){
  .region-label{ transform:translate(-50%,-112%)!important; opacity:1!important; }
}

/* Hide Google Lens bubble */
.gm-style [aria-label*="Visual"],
.gm-style [title*="Visual"],
.gm-style [aria-label*="Lens"],
.gm-style [title*="Lens"],
.gm-style .widget-visual-search,
.gm-style .scene-viewcard-button,
.gm-style .app-viewcard-strip{ display:none !important; }

/* ===== Home-base hover card (no Google white bubble) ===== */
.hb-card{
  --hb-accent:#3B82F6;
  position:absolute;
  transform:translate(-50%,-100%);
  min-width: 280px;
  padding: 10px 12px;
  border-radius: 12px;
  background:
    radial-gradient(160% 120% at 10% 0%,
      color-mix(in srgb, var(--hb-accent) 18%, #fff),
      #fff 70%);
  border: 1px solid color-mix(in srgb, var(--hb-accent) 42%, transparent);
  box-shadow: 0 10px 28px rgba(0,0,0,.22);
  pointer-events:none;
}
.hb-card .t{
  font-weight: 900;
  font-size: 16px;
  letter-spacing:.2px;
  margin-bottom: 4px;
  color:#0c172a;           /* darker for clarity */
}
.hb-card .a{
  font-size: 14.5px;
  line-height: 1.38;
  color:#1f2937;           /* darker address text */
  opacity:.95;
}
/* Google InfoWindow chrome → transparent so only our colored card shows */
.gm-style .gm-style-iw-c{ background:transparent !important; box-shadow:none !important; }
.gm-style .gm-style-iw-t::after{ display:none !important; }

/* Our hover card: larger, clearer */
.hb-iw{
  --hb-accent:#3B82F6;          /* overridden per pin */
  min-width: 280px;
  border-radius: 14px;
  padding: 10px 12px;
  background:
    radial-gradient(120% 100% at 0% 0%, color-mix(in srgb, var(--hb-accent) 22%, #fff), #fff),
    #fff;
  border: 1px solid color-mix(in srgb, var(--hb-accent) 55%, transparent);
  box-shadow: 0 10px 28px rgba(0,0,0,.22);
}
.hb-iw .hb-title{
  font-weight: 900;
  font-size: 17px;
  letter-spacing: .25px;
  margin-bottom: 6px;
  color:#0b1320;
}
.hb-iw .hb-addr{
  font-size: 14.5px;
  line-height: 1.45;
  color:#0b1320;
  opacity:.92;
}

/* ===========================================================
   RIGHT DRAWER + SLIM TAB (with accent color)
   =========================================================== */
#areasBtn{
  position:absolute; right:0; top:50%; transform:translateY(-50%);
  z-index:8;
  background:#fff; border:1px solid #d7d7d7; border-right:none;
  border-top-left-radius:12px; border-bottom-left-radius:12px;
  padding:8px 10px; width:38px; cursor:pointer;
  box-shadow:0 2px 6px rgba(0,0,0,.25);
  display:flex; align-items:center; justify-content:center;
}
#areasBtn .material-icons{font-size:22px; transition:transform .18s ease;}
#areasBtn.open .material-icons{ transform:rotate(180deg); }

#areasDrawer{
  position:absolute; right:12px; top:58px; z-index:8; width:360px;
  max-height:calc(100% - 70px); overflow:auto;
  background:#fff; border:1px solid #d7d7d7; border-radius:14px;
  box-shadow:0 8px 24px rgba(0,0,0,.22);
  transform:translateX(calc(100% + 16px)); transition:transform .18s ease;
  font-size:14.5px;
}
#areasDrawer.open{ transform:translateX(0); }
#areasDrawer header{
  position:sticky; top:0; background:linear-gradient(#f7f7f7,#efefef);
  border-bottom:1px solid #e2e2e2; padding:10px 14px;
  font-weight:800; color:#1f2937; letter-spacing:.2px;
  border-top-left-radius:14px; border-top-right-radius:14px;
  display:flex; align-items:center; gap:8px;
}
#drawerTitle{ flex:1; }
#drawerClose{
  width:30px; height:30px; border-radius:8px; border:1px solid #d7d7d7; background:#fff; cursor:pointer;
  display:inline-flex; align-items:center; justify-content:center;
}
#drawerClose .material-icons{ font-size:20px; }
#drawerClose:hover{ background:#f3f4f6; }

/* generic sections */
#areasDrawer .sec{ padding:10px 14px; border-bottom:1px dashed #ececec; }
#areasDrawer .sec:last-child{ border-bottom:none; }
#areasDrawer h4{ margin:0 0 8px 0; font-size:13.5px; color:#374151; text-transform:uppercase; letter-spacing:.35px; }
#areasDrawer .row{ display:flex; align-items:center; gap:8px; margin:6px 0; padding:0; }
#areasDrawer .hint{ font-size:11.5px; color:#6b7280; }

/* Filter on top (slimmer) */
#secFilterTop .row{ gap:8px; }
#secFilterTop input[type="text"]{
  height:30px; border-radius:10px; border:1px solid #cfcfcf;
  padding:4px 10px; font-size:14px; flex:1;
}
#secFilterTop button{
  border:1px solid #cfcfcf; border-radius:10px; padding:6px 10px; background:#fafafa; cursor:pointer;
}
#secFilterTop button:hover{ background:#f3f4f6; }

/* Grouped polygon list – with soft accent */
.group{
  --accent:#3B82F6; /* default; per-group overridden inline via style */
  border:1px solid #eaeaea; border-radius:12px; margin:10px 0; overflow:hidden; background:#fff;
  box-shadow:0 1px 2px rgba(0,0,0,.03);
}
.group-header{
  display:grid; grid-template-columns: 28px 1fr; align-items:center; gap:6px;
  padding:8px 10px;
  background:linear-gradient(90deg, color-mix(in srgb, var(--accent) 10%, #fff), #fafafa 60%);
  border-bottom:1px solid #eee;
  border-left:4px solid color-mix(in srgb, var(--accent) 55%, transparent);
}
.group-header .toggle{
  width:28px; height:28px; border-radius:8px; border:1px solid color-mix(in srgb, var(--accent) 45%, #ddd); background:#fff; cursor:pointer;
  display:inline-flex; align-items:center; justify-content:center;
}
.group-header .toggle .material-icons{ font-size:18px; transition:transform .18s ease; }
.group.collapsed .group-header .toggle .material-icons{ transform:rotate(-90deg); }

.group-header .gname{
  width:100%; height:30px; padding:4px 8px;
  border:1px solid #cfcfcf; border-radius:8px;
  background:color-mix(in srgb, var(--accent) 6%, #fff);
  font-weight:700;
}
.group-body{ padding:8px 10px; display:flex; flex-direction:column; gap:8px; }
.group.collapsed .group-body{ display:none; }

/* Single polygon row (no eye icon; single checkbox controls visibility) */
.poly-row{
  display:grid; grid-template-columns: 24px 1fr 30px; align-items:center;
  gap:8px; padding:6px 8px; border:1px solid #e8e8e8; border-radius:10px;
  background:#ffffff; transition:box-shadow .12s, border-color .12s;
}
.group .poly-row:hover{
  box-shadow:0 2px 10px rgba(0,0,0,.06);
  border-color:color-mix(in srgb, var(--accent) 35%, #dfdfdf);
}
.poly-row:focus-within{
  box-shadow:0 0 0 3px color-mix(in srgb, var(--accent) 20%, #3B82F6);
  border-color:color-mix(in srgb, var(--accent) 45%, #3B82F6);
}
.poly-row .ck input[type="checkbox"]{ width:18px; height:18px; margin:0; }

.poly-row .name input{
  width:100%; height:32px; padding:6px 8px;
  border:1px solid #cfcfcf; border-radius:8px; background:#fff;
}
.poly-row .name input:focus{
  outline:none; border-color:#3B82F6; box-shadow:0 0 0 3px rgba(59,130,246,.18);
}

.poly-row .swatch{
  width:26px; height:26px; border-radius:6px; border:1px solid rgba(0,0,0,.18);
  cursor:pointer; box-shadow: inset 0 0 0 1px rgba(255,255,255,.45);
}
#areasDrawer input[type="color"]{ width:0; height:0; padding:0; border:none; visibility:hidden; }

/* Style section spacing */
#secStyle .row{ margin-top:6px; }
#secStyle label{ min-width:90px; color:#374151; }
#areasDrawer input[type="range"]{ width:100%; }

/* Make Google’s InfoWindow shell transparent so only our pill shows */
.gm-style-iw-c, .gm-style-iw{
  background: transparent !important;
  box-shadow: none !important;
  border: none !important;
}
.gm-style-iw-tc{ display:none !important; }   /* hide the little white tip */
.gm-style-iw-d { overflow: visible !important; }

/* ===== Home-base info bubble (solid colored pill) ===== */
.hb-iw{
  --hb-accent:#3B82F6;
  min-width:260px;
  padding:8px 12px;
  border-radius:12px;
  background:var(--hb-accent);
  color:#fff;
  border:1px solid rgba(0,0,0,.35);           /* clearer outline */
  box-shadow:0 8px 24px rgba(0,0,0,.25);
}
.hb-iw .hb-title{ font-weight:800; font-size:15px; margin-bottom:2px; color:#fff; }
.hb-iw .hb-addr { font-size:13.5px; line-height:1.35; color:#fff; opacity:.95; }

/* ===== Home-base info bubble theme ===== */
/* ===== Home-base info bubble (solid colored pill, bigger text) ===== */
.hb-iw{
  --hb-accent:#3B82F6;
  min-width:300px;
  padding:10px 14px;
  border-radius:12px;
  background:var(--hb-accent);
  color:#fff;
  border:1px solid rgba(0,0,0,.35);
  box-shadow:0 10px 28px rgba(0,0,0,.28);
}
.hb-iw .hb-title{ font-weight:900; font-size:18px; margin-bottom:4px; color:#fff; }
.hb-iw .hb-addr { font-size:15px; line-height:1.4; color:#fff; opacity:.98; }

.hb-iw .hb-title {
  font-weight: 800;
  font-size: 15px;
  letter-spacing: .2px;
  margin-bottom: 4px;
  color: #0f1720;
}
.hb-iw .hb-addr {
  font-size: 13.5px;
  line-height: 1.35;
  color: #273142;
}
</style>
  

</style>

<script>
function init(){ if(window.routePlannerInit) window.routePlannerInit(); else window.__mapsApiReady=true; }
</script>
<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDnpSCHQWHr1neHALY-xddNne_S7f608co&callback=init&libraries=places,geometry&loading=async"></script>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>

<body>
<div id="panel">
  <div id="scroller">
    <div id="content">
      <div id="timelineCol"><div id="timeline"></div></div>
      <div id="framesContainer"></div>
    </div>
    <div id="msg"></div>
  </div>
</div>

<!-- ---------- FLAT (directions list) ---------- -->
<div id="addrBar">
  <div id="addrBarHeader">
    <span id="addrTitle">Directions</span>
    <div id="addrToggles">
      <span id="toggleDay"   class="toggleChip day">Day</span>
      <span id="toggleNight" class="toggleChip night">Night</span>
    </div>
    <button id="addrAdd" title="Add stop">+</button>
  </div>
  <div id="addrList"></div>
  <div id="addrFooter">
    <div id="flatMsg"></div>
    <div id="flatButtons">
      <button id="flatOpt" class="toggleChip action" type="button">Optimize</button>
      <button id="flatDelSel">Delete Selected</button>
    </div>
  </div>
</div>

<!-- ---------- OUR dropdown root ---------- -->
<div id="sgRoot" class="sg"><ul></ul></div>

<!-- ---------- RIGHT DRAWER TAB + PANEL ---------- -->
<button id="areasBtn" type="button" aria-label="Open Areas drawer" title="Areas">
  <span class="material-icons">chevron_left</span>
</button>

<div id="areasDrawer" aria-hidden="true">
  <header>
    <span id="drawerTitle">Geo Area Polygon Settings</span>
    <button id="drawerClose" type="button" title="Close"><span class="material-icons">chevron_right</span></button>
  </header>

  <!-- Filter (slim) -->
  <div class="sec" id="secFilterTop">
    <div class="row">
      <input id="filterText" type="text" placeholder="Filter groups or areas…">
      <button id="filterClear" type="button">Clear</button>
    </div>
    <div class="hint">Matches group <b>name</b>, area <b>name</b>, or <b>code</b> (e.g., RUT-S, WEST2).</div>
  </div>

  <!-- Groups + polygons -->
  <div class="sec" id="secPolys">
    <h4>Polygons</h4>
    <div id="groupsRoot"></div>
  </div>

  <!-- Style -->
  <div class="sec" id="secStyle">
    <h4>Style</h4>
    <div class="row">
      <label>Opacity</label>
      <input id="opacityRange" type="range" min="0" max="1" step="0.01" value="0.20">
      <span id="opacityVal" class="hint">0.20</span>
    </div>
    <div class="row">
      <label>Stroke</label>
      <input id="strokeRange" type="range" min="0" max="3" step="0.1" value="1.3">
      <span id="strokeVal" class="hint">1.3</span>
    </div>
  </div>
</div>

<div id="map"></div>

<script>
/* =================== CONFIG / CONSTANTS =================== */
const BASE_EMPTY_PER_FRAME = 4;
const INITIAL_FLAT_ROWS    = 2;
const LABEL_COLOR_MODE = 'hash';
const LABEL_USE_ANIM = false;
const LABEL_ANIM_MS  = 30;
const TOL_PCT = 0.03, TOL_KM = 0.30;

let map,dirSvc,dirRend,geocoder,acService,placeSvc,dmSvc;
let previewPins=[],routeMarkers=[];
let autoTimer=null, autoResolveNext=false;

/* Default view must be FLAT */
let dayVisible=false, nightVisible=false, flatMode=false;

let OK_BOUNDS;
const frameInitialized = new Map();

/* ---------- GEOJSON SOURCES ---------- */
const LAYERS = [
  { id:'geo_areas',   name:'Geo Areas (all)',                 file:'Geo Areas.geojson' },
  { id:'kel_central', name:'Kelowna – Central',               file:'Kelowna - Central.geojson' },
  { id:'kel_south',   name:'Kelowna – South',                 file:'Kelowna - South.geojson' },
  { id:'rut_lc',      name:'Rutland & Lake Country',          file:'Rutland & Lake Country.geojson' }
];

/* ---------- DEFAULT COLORS ---------- */
const AREA_COLORS = {
  'MISS1':'#FFEA00',
  'MISS2':'#000000',
  'RUT-S':'#C2185B',
  'RUT-N':'#0288D1',
  'RUT-LC':'#CE93D8',
  'CENT-S':'#FF5252',
  'GLNMR':'#0097A7',
  'WEST1':'#9C27B0',
  'WEST2':'#F9A825'
};
let AREA_FILL_OPACITY = 0.20;
let AREA_STROKE_WEIGHT = 1.3;

/* ---------- GROUP DEFINITIONS (fixed membership by code) ---------- */
const GROUP_DEFS = {
  kel_central: { name:'Kelowna Central',          codes:['CENT-S','GLNMR'] },
  kel_south:   { name:'Kelowna South',            codes:['MISS1','MISS2'] },
  rut_lc:      { name:'Rutland & Lake Country',   codes:['RUT-N','RUT-S','RUT-LC'] },
  west_kel:    { name:'West Kelowna',             codes:['WEST1','WEST2'] }
};
const GROUP_STORAGE_KEY = 'geoGroupState_v1';

/* =================== SUGGESTIONS / SEARCH =================== */
function hideAllAutocompleteUIs(){
  document.querySelectorAll('.pac-container').forEach(el=>{
    el.style.display='none';
    el.setAttribute('aria-hidden','true');
  });
}

/* ---------- Suggestion dropdown ---------- */
const SG = (function(){
  const root = document.getElementById('sgRoot');
  const list = root.querySelector('ul');
  let boundInput = null;
  let items = [];
  let hot = -1;

  function openFor(input, predictions){
    boundInput = input;
    items = predictions.slice(0,5).map(p=>({pred:p, text:p.description}));
    render(); position();
    root.style.display = items.length ? 'block' : 'none';
  }
  function render(){
    list.innerHTML = '';
    items.forEach((it, i)=>{
      const li = document.createElement('li');
      li.textContent = it.text;
      if(i===hot) li.classList.add('active');
      li.addEventListener('mousedown', ev=>{ ev.preventDefault(); ev.stopPropagation(); }, {capture:true});
      li.addEventListener('click', ()=> choose(i));
      list.appendChild(li);
    });
  }
  function position(){
    if(!boundInput) return;
    const r = boundInput.getBoundingClientRect();
    const top = r.bottom + window.scrollY + 4;
    const left = r.left + window.scrollX;
    root.style.top = top+'px';
    root.style.left = left+'px';
    root.style.minWidth = Math.max(260, r.width)+'px';
  }
  function hide(){
    root.style.display='none';
    boundInput=null; items=[]; hot=-1; list.innerHTML='';
  }
  function isOpen(){ return root.style.display==='block'; }
  function choose(idx){
    if(!boundInput || !items[idx]){ hide(); return; }
    const p = items[idx].pred;
    placeSvc.getDetails({placeId:p.place_id, fields:['formatted_address','geometry']},
      (place, st)=>{
        if(st===google.maps.places.PlacesServiceStatus.OK && place?.geometry){
          boundInput.value       = place.formatted_address || boundInput.value;
          boundInput.dataset.lat = place.geometry.location.lat();
          boundInput.dataset.lng = place.geometry.location.lng();
          delete boundInput.dataset.dirty;
          scheduleAutoCompute(0, true);
        }
        hide();
        safeFocus(boundInput);
      });
  }
  function move(delta){
    if(!isOpen() || !items.length) return;
    hot = ( (hot + delta + items.length) % items.length );
    render();
  }
  function chooseHot(){ if(hot<0) hot = 0; choose(hot); }

  window.addEventListener('scroll', ()=>{ if(isOpen()) position(); }, true);
  window.addEventListener('resize', ()=>{ if(isOpen()) position(); });

  return {openFor, hide, isOpen, move, chooseHot};
})();

/* debounce helper */
function debounce(fn, ms){ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), ms); }; }

/* Central Okanagan filter */
const OK_DESC = /(Kelowna|West Kelowna|Lake Country|Peachland)/i;

/* get predictions */
const fetchPredictions = debounce((text, cb)=>{
  if(!text || text.trim().length<3){ cb([]); return; }
  acService.getPlacePredictions(
    { input:text, types:['address'], componentRestrictions:{country:'ca'}, locationBias: OK_BOUNDS },
    (preds, status)=>{
      if(status !== google.maps.places.PlacesServiceStatus.OK || !preds){ cb([]); return; }
      const filtered = preds.filter(p=>OK_DESC.test(p.description)).slice(0,5);
      cb(filtered);
    }
  );
}, 120);

/* Focus helper */
function safeFocus(el){ if(!el) return; try{ el.focus({preventScroll:true}); }catch{} setTimeout(()=>{ try{ el.focus({preventScroll:true}); }catch{} },0); }

/* ---------- FRAMES ---------- */
const FRAMES=[
  {id:0,key:'early',     name:'AM Early',     start:'07:00', end:'09:00',  color:'var(--f-early)',     shift:'day'},
  {id:1,key:'late',      name:'AM Late',      start:'09:00', end:'11:00',  color:'var(--f-late)',      shift:'day'},
  {id:2,key:'lunch',     name:'Lunch',        start:'11:00', end:'13:00',  color:'var(--f-lunch)',     shift:'day'},
  {id:3,key:'afternoon', name:'Afternoon',    start:'13:00', end:'15:30',  color:'var(--f-afternoon)', shift:'day'},
  {id:4,key:'aftNight',  name:'Afternoon',    start:'13:30', end:'16:00',  color:'var(--f-afternoon)', shift:'night'},
  {id:5,key:'supper',    name:'Supper',       start:'16:00', end:'18:30',  color:'var(--f-supper)',    shift:'night'},
  {id:6,key:'evening',   name:'Evening',      start:'18:30', end:'21:00',  color:'var(--f-evening)',   shift:'night'},
  {id:7,key:'lateev',    name:'Late Evening', start:'21:00', end:'22:30',  color:'var(--f-lateev)',    shift:'night'}
];

/* ---------- TIMELINE ---------- */
const mins=(h,m)=>h*60+m;
const parseHM=t=>{const [h,m]=t.split(':').map(Number);return mins(h,m);};
const pad=n=>n.toString().padStart(2,'0');
let __buildingTimeline = false;
let __tl_req = 0, __tl_to = 0;
function scheduleTimelineBuild(){
  if(__tl_req) return;
  __tl_req = requestAnimationFrame(() => { __tl_req = 0; buildTimelineFromDOM(); });
}
function forceCloseAutocomplete(inp){
  try{ inp.dispatchEvent(new KeyboardEvent('keydown', {key:'Escape', bubbles:true})); }catch(e){}
  inp.blur(); hideAllAutocompleteUIs(); SG.hide();
}

/* ===========================================================
   REGION LABEL OVERLAY (lazy-define after Maps API loads)
   =========================================================== */
function pickAccentFromName(name=''){
  const accents = ['#2A9D8F','#3B82F6','#475569','#6B8E23']; // teal, blue, slate, olive
  let h=0; for(let i=0;i<name.length;i++){ h = (h*31 + name.charCodeAt(i))>>>0; }
  return accents[h % accents.length];
}

/* Define RegionLabelOverlay only after google.maps is ready. */
function initRegionLabelOverlay(){
  if (window.RegionLabelOverlay) return;
  if (!window.google || !google.maps) return;

  class RegionLabelOverlay extends google.maps.OverlayView{
    constructor(position, title, accent){
      super();
      this.position = position;
      this.title    = title || '';
      this.accent   = accent || '#2A9D8F';
      this.div      = null;
    }
    onAdd(){
      const div = document.createElement('div');
      div.className = 'region-label';
      div.style.setProperty('--accent', this.accent);
      div.innerHTML = `
        <div class="badge">
          <span class="accent"></span>
          <span class="titlewrap"><span class="title">${(this.title||'').replace(/</g,'&lt;')}</span></span>
          <button class="close" type="button" title="Close">×</button>
        </div>`;
      div.querySelector('.close').addEventListener('click', ()=> this.setMap(null));
      this.div = div;
      this.getPanes().overlayMouseTarget.appendChild(div);
      requestAnimationFrame(()=>{
        div.style.transition = 'transform .18s ease, opacity .18s ease';
        div.style.transform  = 'translate(-50%,-112%) scale(1)';
        div.style.opacity    = '1';
      });
    }
    draw(){
      if(!this.div) return;
      const pix = this.getProjection().fromLatLngToDivPixel(this.position);
      this.div.style.left = pix.x + 'px';
      this.div.style.top  = pix.y + 'px';
    }
    onRemove(){
      if(this.div?.parentNode) this.div.parentNode.removeChild(this.div);
      this.div = null;
    }
  }

  window.RegionLabelOverlay = RegionLabelOverlay;
}

/* =================== UI BUILD (frames/rows) =================== */
function setFrameCollapsed(id, collapse){
  const el = document.querySelector(`.frame[data-frame="${id}"]`);
  if(!el) return;
  if(collapse) el.classList.add('collapsed'); else el.classList.remove('collapsed');
  if(!collapse){ ensurePlaceholdersForFrame(id, {force:false}); buildTimelineForFrame(id); }
  renumber();
  scheduleTimelineBuild();
}

function buildFrameBuckets(){
  const container = document.getElementById('framesContainer');

  FRAMES.forEach(fr=>{
    const sec = document.createElement('div');
    sec.className = 'frame';
    sec.dataset.frame = fr.id;
    sec.dataset.shift = fr.shift;

    const head = document.createElement('div');
    head.className='frame-header';
    head.innerHTML = `
      <span class="swatch" style="background:${fr.color}"></span>
      ${fr.name} <span style="margin-left:10px;font-size:12px;color:#666">(${fr.start}–${fr.end})</span>`;
    const hideBtn = document.createElement('span');
    hideBtn.className = 'material-icons frame-hide';
    hideBtn.textContent = 'visibility_off';
    hideBtn.title = 'Hide / show this time frame';
    hideBtn.onclick = ()=> setFrameCollapsed(fr.id, !sec.classList.contains('collapsed'));
    head.appendChild(hideBtn);
    sec.appendChild(head);

    const body = document.createElement('div');
    body.className = 'frame-body';

    const tl = document.createElement('div');
    tl.className = 'frame-timeline';
    tl.id = 'timeline-frame-'+fr.id;
    body.appendChild(tl);

    const list = document.createElement('div');
    list.className = 'frame-list';
    list.id = 'frame-'+fr.id;
    body.appendChild(list);

    sec.appendChild(body);

    const addBtn = document.createElement('button');
    addBtn.className = 'addRowBtn';
    addBtn.textContent = '+ Add stop';
    addBtn.style.display = 'none';
    addBtn.onclick = ()=> addRowToFrame(fr.id, true, false);
    sec.appendChild(addBtn);

    container.appendChild(sec);

    Sortable.create(list, {
      group: 'stops',
      handle: '.drag',
      animation: 150,
      onEnd: evt => {
        evt.item.dataset.frame = list.parentElement.parentElement.dataset.frame;
        renumber();
        scheduleAutoCompute(120,false);
        scheduleTimelineBuild();
      }
    });
  });

  renumber();

  const ro = new ResizeObserver(()=> scheduleTimelineBuild());
  document.querySelectorAll('.frame').forEach(f=> ro.observe(f));

  const mo = new MutationObserver(()=>{
    clearTimeout(__tl_to);
    __tl_to = setTimeout(scheduleTimelineBuild, 50);
  });
  document.querySelectorAll('.frame-list').forEach(fl=> mo.observe(fl, {childList:true, subtree:true}));
}

function rebalanceFrameHeights(){ if(flatMode) return; scheduleTimelineBuild(); }

function makeRow(frameId){
  const d = document.createElement('div');
  d.className = 'row';
  d.dataset.frame = frameId;
  d.innerHTML = `
    <div class="bullet defaultBullet">A</div>
    <input class="stop" placeholder="Enter stop" autocomplete="off" autocorrect="off" spellcheck="false">
    <span class="material-icons drag" title="Drag to reorder">drag_indicator</span>
    <span class="remove" title="Remove stop">×</span>
  `;

  // --- lock toggle on the bullet (click to lock/unlock) ---
  const bullet = d.querySelector('.bullet');
  bullet.addEventListener('click', (ev)=>{
    ev.preventDefault();
    ev.stopPropagation();
    d.classList.toggle('locked');
    if (d.classList.contains('locked')) {
      d.dataset.locked = '1';
    } else {
      delete d.dataset.locked;
    }
  }, true);

  const del = d.querySelector('.remove');
  del.addEventListener('mousedown', e=>{ e.preventDefault(); e.stopPropagation(); }, true);
  del.addEventListener('click', e=>{
    e.preventDefault(); e.stopPropagation();
    d.remove();
    renumber();
    scheduleAutoCompute(120,false);
    scheduleTimelineBuild();
    showDeleteBtns();
  });

  d.addEventListener('click', rowSelectToggle);
  attachInputEvents(d.querySelector('.stop'));
  return d;
}

function addRowToFrame(frameId, focus=true, select=false){
  const list = document.getElementById('frame-'+frameId);
  const row  = makeRow(frameId);
  list.appendChild(row);
  renumber();
  scheduleTimelineBuild();
  if (focus)  safeFocus(row.querySelector('.stop'));
  if (select) setSelected(row,true);
  return row;
}

function insertRowAfter(currentRow){
  const frameId = +currentRow.dataset.frame;
  const newRow  = makeRow(frameId);
  currentRow.insertAdjacentElement('afterend', newRow);
  renumber();
  scheduleTimelineBuild();
  return newRow;
}

function ensurePlaceholdersForFrame(frameId, {force=false} = {}){
  const list = document.getElementById('frame-'+frameId); if(!list) return;
  const sec = list.closest('.frame');
  const visible = sec.style.display!=='none' && !flatMode && !sec.classList.contains('collapsed');
  if(!visible) return;
  if(frameInitialized.get(frameId) && !force) return;

  frameInitialized.set(frameId, true);
  const cur = list.querySelectorAll('.row').length;
  for(let i=cur; i<BASE_EMPTY_PER_FRAME; i++) addRowToFrame(frameId, false, false);
}

/* =================== TIMELINE =================== */
function buildTimelineFromDOM(){
  if(flatMode) return;
  if(__buildingTimeline) return;
  __buildingTimeline = true;
  try{
    FRAMES.forEach(fr=>{
      const sec=document.querySelector(`.frame[data-frame="${fr.id}"]`);
      const visible=(fr.shift==='day'?dayVisible:nightVisible) &&
                     !sec.classList.contains('collapsed') &&
                     sec.style.display!=='none';
      const tl=document.getElementById('timeline-frame-'+fr.id);
      if(!tl) return;
      tl.innerHTML='';
      if(!visible) return;
      buildTimelineForFrame(fr.id);
    });
    renumber();
  } finally { __buildingTimeline = false; }
}
function buildTimelineForFrame(frameId){
  const meta=FRAMES.find(f=>f.id===frameId);
  const tl=document.getElementById('timeline-frame-'+frameId);
  const sec=document.querySelector(`.frame[data-frame="${frameId}"]`);
  const list=sec.querySelector('.frame-list');
  const h=list.offsetHeight||1;

  const seg=document.createElement('div');
  seg.className='tl-seg'; seg.style.top='0px'; seg.style.height=h+'px';
  seg.style.background = getComputedStyle(sec).borderLeftColor;
  tl.appendChild(seg);

  const axis=document.createElement('div');
  axis.className='tl-axis'; axis.style.top='0px'; axis.style.height=h+'px';
  tl.appendChild(axis);

  const startM=parseHM(meta.start), endM=parseHM(meta.end);
  const span=endM-startM||1;
  const step=30;
  for(let t=startM;t<=endM;t+=step){
    const y=(t-startM)/span*h; addTick(t,y,t%60===0);
  }
  if((endM-startM)%step!==0) addTick(endM, h, true);

  const now=new Date(); const m=now.getHours()*60+now.getMinutes();
  if(m>=startM && m<=endM){
    const y=(m-startM)/span*h; const mark=document.createElement('div');mark.className='nowMarker';mark.style.top=y+'px'; tl.appendChild(mark);
  }
  function addTick(totalMins,y,bold=false){
    const tick=document.createElement('div');tick.className='tl-tick'+(bold?' bold':'');tick.style.top=y+'px';
    const lbl=document.createElement('div');lbl.className='tl-label';lbl.textContent=`${pad(Math.floor(totalMins/60))}:${pad(totalMins%60)}`;
    lbl.style.top='-6px';tick.appendChild(lbl);tl.appendChild(tick);
  }
}

/* =================== SELECT / DELETE / NUMBERING =================== */
function rowSelectToggle(e){
  if(!(e.ctrlKey||e.metaKey)) return;
  e.currentTarget.classList.toggle('selected');showDeleteBtns();
}
function setSelected(row,on){
  document.querySelectorAll('.row.selected').forEach(r=>r.classList.remove('selected'));
  if(on) row.classList.add('selected'); showDeleteBtns();
}
function showDeleteBtns(){
  const any=document.querySelector('.row.selected');
  const flatDel=document.getElementById('flatDelSel');
  if(flatDel) flatDel.style.display=any&&flatMode?'inline-block':'none';
}
function deleteSelected(){
  document.querySelectorAll('.row.selected').forEach(r=>r.remove());
  showDeleteBtns();renumber();scheduleAutoCompute(120,false);scheduleTimelineBuild();
}
document.addEventListener('keydown',e=>{
  if((e.key==='Delete'||e.key==='Backspace')&&document.querySelector('.row.selected')){
    e.preventDefault();deleteSelected();
  }
});
document.addEventListener('click',e=>{
  if(e.ctrlKey||e.metaKey) return;
  if(!document.querySelector('.row.selected')) return;
  const inRow = e.target.closest('.row');
  const onDel = e.target.closest('#flatDelSel');
  if(inRow || onDel) return;
  document.querySelectorAll('.row.selected').forEach(r=>r.classList.remove('selected'));
  showDeleteBtns();
}, true);

function idxToLabel(i){let s='',n=i+1;while(n>0){const r=(n-1)%26;s=String.fromCharCode(65+r)+s;n=Math.floor((n-1)/26);}return s;}
function isLocked(row){ return row?.dataset?.locked === '1' || row?.classList?.contains('locked'); }
function renumber(){
  if(flatMode){
    const rows=[...document.querySelectorAll('#addrList .row')];
    rows.forEach((r,i)=>{
      const b=r.querySelector('.bullet'); b.textContent=idxToLabel(i);
      b.className='bullet '+(['A','B','C','D','E','F','G','H'][i%8]||'defaultBullet');
    });
    return;
  }
  let i=0;
  FRAMES.forEach(fr=>{
    const sec=document.querySelector(`.frame[data-frame="${fr.id}"]`);
    const vis=(fr.shift==='day'&&dayVisible)||(fr.shift==='night'&&nightVisible);
    if(!vis || sec.classList.contains('collapsed') || sec.style.display==='none') return;
    const rows=[...document.getElementById('frame-'+fr.id).querySelectorAll('.row')];
    rows.forEach(r=>{
      const b=r.querySelector('.bullet'); b.textContent=idxToLabel(i);
      b.className='bullet '+(['A','B','C','D','E','F','G','H'][i%8]||'defaultBullet');
      i++;
    });
  });
}

/* =================== INPUT / AUTOCOMPLETE =================== */
function attachInputEvents(inp){
  inp.addEventListener('mousedown',ev=>{
    if(document.activeElement!==inp){ ev.preventDefault(); safeFocus(inp); setTimeout(()=>inp.select(),0); }
  });
  inp.addEventListener('focus', e=>{
    inp.closest('.row').classList.add('focused');
    setTimeout(()=>e.target.select(),0);
    if(!inp.dataset.lat && (inp.value||'').trim().length>=3){
      fetchPredictions(inp.value, preds => SG.openFor(inp, preds));
    }
  });
  inp.addEventListener('blur',()=>{
    inp.closest('.row').classList.remove('focused');
    setTimeout(()=>{ if(document.activeElement!==inp) SG.hide(); }, 150);
  });
  inp.addEventListener('input',()=>{
    inp.dataset.dirty='1'; inp.dataset.lat=''; inp.dataset.lng='';
    scheduleAutoCompute(200,false);
    if((inp.value||'').trim().length>=3){
      fetchPredictions(inp.value, preds => SG.openFor(inp, preds));
    }else{
      SG.hide();
    }
  });

  inp.addEventListener('keydown', e=>{
    if(!SG.isOpen()) return;
    if(e.key==='ArrowDown'){ e.preventDefault(); SG.move(+1); }
    if(e.key==='ArrowUp'){   e.preventDefault(); SG.move(-1); }
  });

  inp.addEventListener('keydown', e => {
    const isAdvanceKey = (e.key === 'Enter') || (e.key === 'Tab' && !e.shiftKey);
    if (!isAdvanceKey) return;

    e.preventDefault(); e.stopPropagation(); e.stopImmediatePropagation();
    forceCloseAutocomplete(inp);

    if(SG.isOpen() && e.key==='Enter'){ SG.chooseHot(); return; }

    if (flatMode) { focusNextInFlatOrCreate(inp, true); }
    else          { focusNextInFrameOrCreate(inp, true); }

    acceptTopPrediction(inp, { advance:false });
    SG.hide();
    scheduleAutoCompute(150, true);
  });

  inp.addEventListener('paste',multiPaste);
}

/* ---------- Focus helpers ---------- */
function focusNextInFrameOrCreate(currentInput, queueOnly=false){
  const currentRow = currentInput.closest('.row');
  const frameId    = +currentRow.dataset.frame;
  const list       = document.getElementById('frame-'+frameId);
  const rows       = [...list.querySelectorAll('.row')];
  const idx        = rows.indexOf(currentRow);

  const firstEmptyAfter = rows.slice(idx+1).find(r => !r.querySelector('.stop').value.trim());
  let target;
  if(firstEmptyAfter){
    target = firstEmptyAfter.querySelector('.stop');
  }else{
    if(rows[idx+1]){
      const newRow = insertRowAfter(currentRow);
      target = newRow.querySelector('.stop');
    }else{
      const added = addRowToFrame(frameId, false, false);
      target = added.querySelector('.stop');
    }
  }
  if(queueOnly) setTimeout(()=>safeFocus(target),0); else safeFocus(target);
}
function focusNextInFlatOrCreate(currentInput, queueOnly=false){
  const currentRow = currentInput.closest('.row');
  const list       = document.getElementById('addrList');
  const rows       = [...list.querySelectorAll('.row')];
  const idx        = rows.indexOf(currentRow);

  const firstEmptyAfter = rows.slice(idx+1).find(r => !r.querySelector('.stop').value.trim());
  let target;
  if(firstEmptyAfter){
    target = firstEmptyAfter.querySelector('.stop');
  }else{
    const newRow = makeRow(0);
    list.appendChild(newRow);
    renumber();
    target = newRow.querySelector('.stop');
  }
  if(queueOnly) setTimeout(()=>safeFocus(target),0); else safeFocus(target);
}
// === Shared helper so OCR and text multi-paste use the SAME pipeline ===
async function applyAddressesList(startInput, lines){
  const addresses = (lines || []).map(s => (s||'').replace(/\s+/g,' ').trim()).filter(Boolean);
  if (!addresses.length) return;

  const startRow = startInput.closest('.row');

  if (flatMode){
    const list = document.getElementById('addrList');
    let rows   = [...list.querySelectorAll('.row')];
    const startIdx = rows.indexOf(startRow);

    const need = Math.max(0, startIdx + addresses.length - rows.length);
    for (let i=0; i<need; i++) list.appendChild(makeRow(0));
    rows = [...list.querySelectorAll('.row')];

    addresses.forEach((addr,i)=>{
      const r = rows[startIdx + i]; if (!r) return;
      const el = r.querySelector('.stop');
      el.value = addr; el.dataset.lat=''; el.dataset.lng=''; el.dataset.dirty='1';
    });

    renumber();
    autoResolveNext = true;
    const span = rows.slice(startIdx, startIdx + addresses.length);
    await ensureCoords(span, {parallel:true});
    await rebuildRoute();
    return;
  }

  // ----- framed view (same behavior as your old multiPaste) -----
  const firstFrameId       = +startRow.dataset.frame;
  const frMeta             = FRAMES.find(f => f.id === firstFrameId);
  const shift              = frMeta.shift;
  const framesInShift      = FRAMES.filter(f => f.shift === shift);
  const startIndexInShift  = framesInShift.findIndex(f => f.id === firstFrameId);

  const targets = [];
  for (let k=startIndexInShift; k<framesInShift.length && targets.length<addresses.length; k++){
    const fid  = framesInShift[k].id;
    const list = document.getElementById('frame-'+fid);
    ensurePlaceholdersForFrame(fid);
    const rows = [...list.querySelectorAll('.row')];

    let startAt = 0;
    if (fid === firstFrameId) startAt = rows.indexOf(startRow);

    for (let i=startAt; i<rows.length && targets.length<addresses.length; i++){
      const inp = rows[i].querySelector('.stop');
      if (!inp.value.trim()) targets.push(inp);
    }
    while (targets.length < addresses.length && k === framesInShift.length-1){
      const added = addRowToFrame(fid, false, false);
      targets.push(added.querySelector('.stop'));
    }
  }

  targets.forEach((inp,i)=>{
    inp.value = addresses[i]; inp.dataset.lat=''; inp.dataset.lng=''; inp.dataset.dirty='1';
  });

  renumber();
  autoResolveNext = true;
  await ensureCoords(getOrderedRows(true), {parallel:true});
  await rebuildRoute();
}

/* =================== MULTI-PASTE (both views) =================== */
async function multiPaste(e){
  const clip  = (e.clipboardData || window.clipboardData).getData('text');
  const lines = clip.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  if (lines.length <= 1) return;   // keep single-line behavior
  e.preventDefault();
  SG.hide();
  await applyAddressesList(e.target, lines);  // reuse the shared logic
}

/* Accept top prediction on Tab/Enter */
function acceptTopPrediction(input, { advance = true } = {}){
  if (input.dataset.lat && input.dataset.lng){
    delete input.dataset.dirty;
    if (advance){
      if (flatMode) { focusNextInFlatOrCreate(input); }
      else          { focusNextInFrameOrCreate(input); }
    }
    scheduleAutoCompute(0, true);
    return;
  }

  acService.getPlacePredictions(
    { input: input.value, componentRestrictions:{country:'ca'}, types:['address'], locationBias: OK_BOUNDS },
    (preds, status) => {
      if (status !== google.maps.places.PlacesServiceStatus.OK || !preds?.length){
        if (advance){
          if (flatMode) { focusNextInFlatOrCreate(input); }
          else          { focusNextInFrameOrCreate(input); }
        }
        scheduleAutoCompute(0, false);
        return;
      }
      placeSvc.getDetails({ placeId: preds[0].place_id, fields: ['formatted_address','geometry'] },
        (place, st) => {
          if (st === google.maps.places.PlacesServiceStatus.OK && place?.geometry){
            input.value       = place.formatted_address || input.value;
            input.dataset.lat = place.geometry.location.lat();
            input.dataset.lng = place.geometry.location.lng();
            delete input.dataset.dirty;
          }
          if (advance){
            if (flatMode) { focusNextInFlatOrCreate(input); }
            else          { focusNextInFrameOrCreate(input); }
          }
          scheduleAutoCompute(0, true);
        }
      );
    }
  );
}

/* =================== SHIFT / FLAT =================== */
function updateToggleChips(){
  const d=document.getElementById('toggleDay');   if(d) d.classList.toggle('active',dayVisible);
  const n=document.getElementById('toggleNight'); if(n) n.classList.toggle('active',nightVisible);
}
function enforcePanelVisibility(){
  const svOn = map && map.getStreetView().getVisible();
  const panel = document.getElementById('panel');
  const addr  = document.getElementById('addrBar');

  if(svOn){
    panel.style.display = 'none';
    addr.style.display  = 'none';
    return;
  }
  panel.style.display = '';
  if(flatMode){
    panel.classList.add('flat');
    addr.classList.add('active');
    addr.style.display='block';
  }else{
    panel.classList.remove('flat');
    addr.classList.remove('active');
    addr.style.display='none';
  }
}
function toggleShift(which){
  if(which==='day') dayVisible=!dayVisible;
  if(which==='night') nightVisible=!nightVisible;
  applyShiftVisibility();
}
function applyShiftVisibility(){
  const wantFlat = !dayVisible && !nightVisible;
  if (wantFlat) enterFlatMode(); else exitFlatMode();

  FRAMES.forEach(fr=>{
    const sec = document.querySelector(`.frame[data-frame="${fr.id}"]`);
    const vis = (fr.shift==='day' && dayVisible) || (fr.shift==='night' && nightVisible);
    sec.style.display = vis ? 'block' : 'none';
    if (vis && !sec.classList.contains('collapsed')) {
      ensurePlaceholdersForFrame(fr.id, { force:true });
    }
  });

  updateToggleChips();
  rebalanceFrameHeights();
  scheduleTimelineBuild();
  renumber();
  SG.hide();
  hideAllAutocompleteUIs();
  scheduleAutoCompute(120,false);

  enforcePanelVisibility();
}
function buildAddrBar(){
  Sortable.create(document.getElementById('addrList'),{
    handle:'.drag',animation:150, onEnd:()=>{renumber();scheduleAutoCompute(120,false);}
  });
  document.getElementById('toggleDay').onclick=()=>toggleShift('day');
  document.getElementById('toggleNight').onclick=()=>toggleShift('night');
}
function addRowToAddrBar(focus=true,select=false){
  const list=document.getElementById('addrList');
  const row=makeRow(0);list.appendChild(row);renumber();
  if(select) setSelected(row,true);
  if(focus) safeFocus(row.querySelector('.stop'));
  return row;
}
function focusFirstFlatInputIfNone(){
  if(document.activeElement && document.activeElement.classList.contains('stop')) return;
  const list=document.getElementById('addrList');
  const firstEmpty=[...list.querySelectorAll('.stop')].find(i=>!i.value.trim()) || list.querySelector('.stop');
  if(firstEmpty) safeFocus(firstEmpty);
}
function enterFlatMode(){
  if(flatMode) return; flatMode=true;
  clearDirections(); clearLegDisplays();
  SG.hide();
  enforcePanelVisibility();

  const list=document.getElementById('addrList');
  if(list.querySelectorAll('.row').length===0){
    addRowToAddrBar(true,false);
    for(let i=1;i<INITIAL_FLAT_ROWS;i++) addRowToAddrBar(false,false);
  }else{ focusFirstFlatInputIfNone(); }
}
function exitFlatMode(){
  if(!flatMode) return; flatMode=false;
  SG.hide();
  enforcePanelVisibility();
}

/* =================== CLEAR =================== */
function clearAllStops(){
  document.querySelectorAll('.row').forEach(row=>{
    const inp=row.querySelector('.stop');
    row.classList.remove('invalid','selected','focused');
    if(inp){inp.value='';inp.dataset.lat='';inp.dataset.lng='';inp.placeholder='Enter stop'; delete inp.dataset.dirty;}
  });
  frameInitialized.clear();
  clearPreviewPins();clearDirections();clearLegDisplays();
  document.getElementById('msg').textContent='';
  const fm=document.getElementById('flatMsg'); if(fm) fm.textContent='';
  showDeleteBtns(); scheduleTimelineBuild(); renumber();
  SG.hide();
}

/* NEW: clear only the filled inputs in the CURRENT VIEW (flat or visible frames) */
function clearFilledCurrentView(){
  if (flatMode){
    document.querySelectorAll('#addrList .row .stop').forEach(inp=>{
      if((inp.value||'').trim()){
        const r = inp.closest('.row');
        r?.classList.remove('invalid');
        inp.value=''; inp.dataset.lat=''; inp.dataset.lng=''; delete inp.dataset.dirty;
      }
    });
  } else {
    FRAMES.forEach(fr=>{
      const sec=document.querySelector(`.frame[data-frame="${fr.id}"]`);
      const visible=(fr.shift==='day'&&dayVisible)||(fr.shift==='night'&&nightVisible);
      if(!visible || sec.classList.contains('collapsed') || sec.style.display==='none') return;
      document.querySelectorAll(`#frame-${fr.id} .row .stop`).forEach(inp=>{
        if((inp.value||'').trim()){
          const r = inp.closest('.row');
          r?.classList.remove('invalid');
          inp.value=''; inp.dataset.lat=''; inp.dataset.lng=''; delete inp.dataset.dirty;
        }
      });
    });
  }
  renumber();
  scheduleAutoCompute(0,false);
}

/* =================== ROUTING / DISPLAY =================== */
const scheduleAutoCompute=(ms=120, allowResolve=false)=>{
  clearTimeout(autoTimer);
  autoResolveNext = allowResolve;
  autoTimer=setTimeout(()=>autoCompute(),ms);
};
const TEARDROP_PATH = "M0,-28 C-8,-28 -14,-22 -14,-14 c0,11 14,28 14,28 s14,-17 14,-28 C14,-22 8,-28 0,-28 z";
function clearDirections(){dirRend.set('directions',null);dirRend.setMap(null);dirRend.setMap(map);clearRouteMarkers();}
function addPreviewPin(latlng,label){
  const marker=new google.maps.Marker({
    position:latlng,map,
    label:{text:label,color:'#fff',fontSize:'16px',fontWeight:'700'},
icon:{
  path: TEARDROP_PATH,
  scale: 0.80,
  fillColor: '#607d8b',
  fillOpacity: 0.75,
  strokeColor: '#000000',
  strokeWeight: 2.0,
  labelOrigin: new google.maps.Point(0,-16),
  anchor: new google.maps.Point(0,0)
}
  });
  previewPins.push(marker);
}
function clearPreviewPins(){previewPins.forEach(m=>m.setMap(null));previewPins=[];}
function drawRouteMarkers(points, rows){
  points.forEach((p, i) => {
    if (!p) return;

    const b = rows[i]?.querySelector('.bullet');
    const letter = b ? (b.textContent || '').trim() : '';
    const classLetter = b ? [...b.classList].find(c => /^[A-Z]$/.test(c)) : null;
    const varName = classLetter ? `--clr${classLetter}` : '--clrDefault';
    const color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '#607d8b';

    // --- NEW: If this point sits on a home-base pin, reuse that pin and just label it ---
    const hb = getHomeBaseAtLatLng(p, 35);   // 35m tolerance; adjust if needed
    if (hb){
      hb.setLabel({ text: letter, color: '#ffffff', fontSize: '16px', fontWeight: '700' });
      // optionally bump zIndex a bit
      try { hb.setZIndex(200); } catch(_){}
      return; // don't create a second marker
    }

    // --- Otherwise, create a dedicated route marker with strong black outline ---
    const marker = new google.maps.Marker({
      position: p,
      map,
      label: { text: letter, color: '#fff', fontSize: '16px', fontWeight: '700' },
   icon: {
  path: TEARDROP_PATH,
  scale: 0.72,                       // smaller
  fillColor: color,
  fillOpacity: 0.5,                 // more transparent
  strokeColor: '#000000',            // solid black outline
  strokeOpacity: 1,
  strokeWeight: 1.6,
  anchor: new google.maps.Point(0, 0),
  labelOrigin: new google.maps.Point(0, -16)
},
    });

    routeMarkers.push(marker);
  });
}
function clearRouteMarkers(){
  routeMarkers.forEach(m => m.setMap(null));
  routeMarkers = [];
  resetHomeBaseLabels();               // <-- also remove labels from home-base pins
}
/* keep your resolveAddress exactly as-is below */
async function resolveAddress(text){
  const prediction = await new Promise(res=>{
    acService.getPlacePredictions(
      {input:text, componentRestrictions:{country:'ca'}, types:['address'], locationBias:OK_BOUNDS},
      (preds,status)=>{ if(status===google.maps.places.PlacesServiceStatus.OK && preds?.length) res(preds[0]); else res(null); }
    );
  });
  if(prediction){
    const place = await new Promise(res=>{
      placeSvc.getDetails({placeId:prediction.place_id, fields:['formatted_address','geometry']},
        (p,st)=>res(st===google.maps.places.PlacesServiceStatus.OK?p:null));
    });
    if(place?.geometry && OK_BOUNDS.contains(place.geometry.location)){
      return {lat:place.geometry.location.lat(),lng:place.geometry.location.lng(),formatted:place.formatted_address};
    }
  }
  return await geocodeSmart(text);
}
function geocodeSmart(addr,attempt=0){
  return new Promise(res=>{
    geocoder.geocode({address:addr,componentRestrictions:{country:'CA'},bounds:OK_BOUNDS,region:'CA'},
      (results,status)=>{
        if(status==='OK'&&results[0]){
          const loc=results[0].geometry.location;
          if(!OK_BOUNDS.contains(loc)){ res(null); }
          else res({lat:loc.lat(),lng:loc.lng(),formatted:results[0].formatted_address});
        }else if(status==='OVER_QUERY_LIMIT' && attempt<5){
          setTimeout(()=>geocodeSmart(addr,attempt+1).then(res), 250*(attempt+1));
        }else res(null);
      });
  });
}
/* =================== HOME BASE PINS (robust) =================== */

const HOME_BASES = [
  {
    name: 'Lake Country Community Health Centre',
    address: '10080 Main St, Lake Country, BC V4V 1T8',
    // fallback coords (approx)
    lat: 50.03263, lng: -119.41377,
    color: '#2A9D8F'
  },
  {
    name: 'Kelowna May Bennett Wellness Centre',
    address: '135 Davie Rd, Kelowna, BC V1X 1Y8',
    lat: 49.89558, lng: -119.40524,
    color: '#F59E0B'
  },
  {
    name: 'Kelowna Central Office',
    address: '1815 Kirschner Rd, Kelowna, BC V1Y 4N7',
    lat: 49.87232, lng: -119.46434,
    color: '#3B82F6'
  },
  {
    name: 'West Kelowna Health Centre',
    address: '2300 Carrington Rd, West Kelowna, BC V4T 2N6',
    lat: 49.83988, lng: -119.61036,
    color: '#8B5CF6'
  }
];

let HOME_BASE_MARKERS = [];

/* === Home-base helpers (match + reset) === */
function getHomeBaseAtLatLng(latlng, tolMeters = 30){
  if (!Array.isArray(HOME_BASE_MARKERS) || !HOME_BASE_MARKERS.length) return null;

  // Haversine distance in meters
  const toRad = x => x * Math.PI / 180;
  const R = 6371000;
  function dist(a, b){
    const dLat = toRad(b.lat() - a.lat());
    const dLng = toRad(b.lng() - a.lng());
    const sa = Math.sin(dLat/2)**2 +
               Math.cos(toRad(a.lat())) * Math.cos(toRad(b.lat())) *
               Math.sin(dLng/2)**2;
    return 2 * R * Math.asin(Math.sqrt(sa));
  }

  const target = new google.maps.LatLng(latlng.lat, latlng.lng);
  for (const m of HOME_BASE_MARKERS){
    try{
      const d = dist(m.getPosition(), target);
      if (d <= tolMeters) return m;
    }catch(_){}
  }
  return null;
}

function resetHomeBaseLabels(){
  HOME_BASE_MARKERS.forEach(m => m.setLabel(null));
}

/** first available stop input in current view */
function firstEmptyStopInput() {
  if (window.flatMode) {
    const list = document.getElementById('addrList');
    return [...list.querySelectorAll('.stop')].find(i => !(i.value||'').trim()) || list.querySelector('.stop');
  }
  for (const fr of FRAMES) {
    const sec = document.querySelector(`.frame[data-frame="${fr.id}"]`);
    const visible = (fr.shift==='day' && dayVisible) || (fr.shift==='night' && nightVisible);
    if (!visible || sec.classList.contains('collapsed') || sec.style.display==='none') continue;
    const list = document.getElementById('frame-'+fr.id);
    const inp  = [...list.querySelectorAll('.stop')].find(i => !(i.value||'').trim());
    if (inp) return inp;
  }
  return null;
}
function initHBTooltip(){
  // Only after Maps API is ready
  if (!window.google || !google.maps) return;

  // Define the overlay class once
  if (!window.HBTooltip){
    class HBTooltip extends google.maps.OverlayView{
      constructor(){
        super();
        this.div = null;
        this.pos = null;
        this.name = '';
        this.addr = '';
        this.accent = '#3B82F6';
      }

      onAdd(){
        const d = document.createElement('div');
        d.className = 'hb-card';
        d.style.pointerEvents = 'none';             // IMPORTANT: no mouse capture
        this.div = d;
        // floatPane so it never becomes a mouse target
        this.getPanes().floatPane.appendChild(d);
      }

      draw(){
        if (!this.div || !this.pos) return;
        const proj = this.getProjection();
        const p = proj && proj.fromLatLngToDivPixel(this.pos);
        if (!p) return;
        this.div.style.left = p.x + 'px';
        this.div.style.top  = (p.y - 12) + 'px';
        this.div.style.transform = 'translate(-50%,-100%)';
      }

      onRemove(){
        this.div?.remove();
        this.div = null;
      }

      show(latLng, name, addr, accent){
        this.pos    = latLng;
        this.name   = name || '';
        this.addr   = addr || '';
        this.accent = accent || '#3B82F6';

        // paint content
        if (this.div){
          const esc = s => String(s||'').replace(/[<>&]/g, m => ({'<':'&lt;','>':'&gt;','&':'&amp;'}[m]));
          this.div.style.setProperty('--hb-accent', this.accent);
          this.div.innerHTML = `<div class="t">${esc(this.name)}</div><div class="a">${esc(this.addr)}</div>`;
          this.div.style.display = 'block';
        }

        if (!this.getMap()) this.setMap(window.map);
        this.draw();
      }

      hide(){
        if (this.div) this.div.style.display = 'none';
      }
    }
    window.HBTooltip = HBTooltip;
  }

  // Singleton instance
  if (!window.__hbTip) window.__hbTip = new window.HBTooltip();
}

/** add subdued pins, hover tooltip, and click-to-fill */
function initHomeBasePins(){
  if (!window.map || !window.google) return; // run only after Maps is ready
  console.debug('[home-bases] initializing pins…');

  // clean up on re-init
  HOME_BASE_MARKERS.forEach(m => m.setMap(null));
  HOME_BASE_MARKERS = [];

  const fit = new google.maps.LatLngBounds();

// define the tooltip class (if not already) and reuse a single instance
initHBTooltip();
const hbTip = window.__hbTip;  // singleton
  
  // Hide hover card if user clicks elsewhere on the map
map.addListener('click', () => hbTip.hide());

  HOME_BASES.forEach(async (base) => {
    // try resolve; if it fails use fallback lat/lng
    let resolved = null;
    try { resolved = await resolveAddress(base.address); } catch {}

    const lat = resolved?.lat ?? base.lat;
    const lng = resolved?.lng ?? base.lng;
    const formatted = resolved?.formatted || base.address;

    if (!Number.isFinite(lat) || !Number.isFinite(lng)) {
      console.warn('[home-bases] could not locate:', base.name, base.address);
      return;
    }

    const pos = new google.maps.LatLng(lat, lng);
    fit.extend(pos);

    const marker = new google.maps.Marker({
      position: pos,
      map,
      zIndex: 50,
      icon: {
        path: TEARDROP_PATH,
        scale: 0.85,
        fillColor: base.color,
        fillOpacity: 0.60,
        strokeColor: '#000000',
        strokeOpacity: 1,
        strokeWeight: 1.8,
        anchor: new google.maps.Point(0, 0),
        labelOrigin: new google.maps.Point(0, -16)
      },
      title: '',
      optimized: true
    });

// hover handlers
marker.addListener('mouseover', (e) => {
  const at = (e && e.latLng) ? e.latLng : marker.getPosition();
  hbTip.show(at, base.name, formatted, base.color);
});
marker.addListener('mouseout', () => hbTip.hide());

// click → paste first available input, lock it, set coords, recompute
marker.addListener('click', () => {
  hbTip.hide();
  const row = fillFirstAvailableAddress(formatted, {
    lock: true,
    coords: { lat, lng }
  });
  if (!row) {
    if (window.flatMode) {
      const r = addRowToAddrBar(true, false);
      fillFirstAvailableAddress(formatted, { lock: true, coords: { lat, lng } });
    } else {
      const vis = FRAMES.find(fr => {
        const sec = document.querySelector(`.frame[data-frame="${fr.id}"]`);
        return ((fr.shift==='day' && dayVisible) || (fr.shift==='night' && nightVisible)) &&
               sec && !sec.classList.contains('collapsed') && sec.style.display!=='none';
      });
      if (vis) {
        addRowToFrame(vis.id, true, false);
        fillFirstAvailableAddress(formatted, { lock: true, coords: { lat, lng } });
      }
    }
  }
});

    HOME_BASE_MARKERS.push(marker);
  });

  // keep markers in view (leaving space for the left panel)
  setTimeout(() => {
    if (HOME_BASE_MARKERS.length) {
      try {
        map.fitBounds(fit, { top: 60, right: 40, bottom: 80, left: 380 });
      } catch {}
    }
  }, 0);
}

// ===== hover: show our custom colored card (no white bubble) =====
  
/* Find/create first available input, fill it, optionally lock and set coords. */
function fillFirstAvailableAddress(addr, { lock=false, coords=null } = {}){
  let input = null, row = null;

  if (flatMode){
    input = [...document.querySelectorAll('#addrList .stop')].find(i=>!i.value.trim());
    if (!input){
      const r = addRowToAddrBar(true,false);
      input = r.querySelector('.stop');
    }
  } else {
    const frames = FRAMES.filter(fr=>{
      const sec = document.querySelector(`.frame[data-frame="${fr.id}"]`);
      const visible = (fr.shift==='day'&&dayVisible) || (fr.shift==='night'&&nightVisible);
      return visible && sec && !sec.classList.contains('collapsed') && sec.style.display!=='none';
    });
    for (const fr of frames){
      const list = document.getElementById('frame-'+fr.id);
      input = [...list.querySelectorAll('.stop')].find(i=>!i.value.trim());
      if (input) break;
    }
    if (!input && frames.length){
      const r = addRowToFrame(frames[0].id, true, false);
      input = r.querySelector('.stop');
    }
  }

  if (!input) return null;

  row = input.closest('.row');
  input.value = addr;

  if (coords && Number.isFinite(coords.lat) && Number.isFinite(coords.lng)){
    input.dataset.lat = String(coords.lat);
    input.dataset.lng = String(coords.lng);
    delete input.dataset.dirty;
  }else{
    input.dataset.lat=''; input.dataset.lng=''; input.dataset.dirty='1';
  }

  if (lock && row){
    row.classList.add('locked');
    row.dataset.locked = '1';
  }

  safeFocus(input);
  renumber();
  autoResolveNext = true;
  scheduleAutoCompute(0, true);
  return row;
}

async function ensureCoords(rows,{parallel=false}={}){
  const tasks = rows.map(row=>async ()=>{
    const inp=row.querySelector('.stop');
    row.classList.remove('invalid');
    if(!inp.value) return true;
    if(inp.dataset.lat && inp.dataset.lng) return true;
    const out = await resolveAddress(inp.value);
    if(out){ inp.dataset.lat=out.lat; inp.dataset.lng=out.lng; inp.value=out.formatted; delete inp.dataset.dirty; return true; }
    row.classList.add('invalid'); inp.placeholder='Unrecognised – edit me'; return false;
  });

  if(!parallel){
    for(const t of tasks){ const ok=await t(); if(!ok) return false; }
    return true;
  }else{
    const CONC=4; let i=0, okAll=true;
    await Promise.all(Array.from({length:CONC},async ()=>{
      while(i<tasks.length){ const my=i++; const ok=await tasks[my](); if(!ok) okAll=false; }
    }));
    return okAll;
  }
}
function getOrderedRows(includeHidden=false){
  if(flatMode) return [...document.querySelectorAll('#addrList .row')].filter(r=>r.querySelector('.stop').value.trim());
  const rows=[];
  FRAMES.forEach(f=>{
    const sec=document.querySelector(`.frame[data-frame="${f.id}"]`);
    const vis=(f.shift==='day'&&dayVisible)||(f.shift==='night'&&nightVisible)||includeHidden;
    if(!vis) return;
    if(sec.classList.contains('collapsed') && !includeHidden) return;
    rows.push(...document.getElementById('frame-'+f.id).querySelectorAll('.row'));
  });
  return rows.filter(r=>r.querySelector('.stop').value.trim());
}
async function autoCompute(){
  const rows=getOrderedRows();
  const msg=document.getElementById('msg'), flatMsg=document.getElementById('flatMsg');

  if(rows.filter(r=>r.querySelector('.stop').value.trim()).length===0){
    clearPreviewPins();clearLegDisplays();msg.textContent=''; if(flatMsg) flatMsg.textContent=''; clearDirections();return;
  }
  if(rows.some(r=>!r.querySelector('.stop').dataset.lat)){
    if(autoResolveNext){ await ensureCoords(rows,{parallel:true}); autoResolveNext=false; }
    else{ clearDirections(); clearLegDisplays(); return; }
  }
  if(rows.length===1){
  clearDirections();clearLegDisplays();clearPreviewPins();
  const inp=rows[0].querySelector('.stop');
  const pt = {lat:+inp.dataset.lat, lng:+inp.dataset.lng};
  addPreviewPin(pt,'A');

  // NEW: focus the map so the geo-area color is clearly visible
  if (map && Number.isFinite(pt.lat) && Number.isFinite(pt.lng)){
    map.panTo(pt);
    // a crisp “see the polygon” level for your area
    const targetZoom = 15; // 14–16 works well; adjust if you prefer
    const z = map.getZoom();
    if (!z || Math.abs(z - targetZoom) > 0.5) map.setZoom(targetZoom);
  }

  msg.textContent=''; if(flatMsg) flatMsg.textContent='';
}else{
    clearPreviewPins(); await rebuildRoute();
  }
}
async function rebuildRoute(){
  const rows=getOrderedRows();
  const msg=document.getElementById('msg'), flatMsg=document.getElementById('flatMsg');
  clearLegDisplays();clearRouteMarkers();
  if(rows.length<2){msg.textContent=''; if(flatMsg) flatMsg.textContent=''; clearDirections();return;}
  const ok=await ensureCoords(rows,{parallel:true});
  if(!ok){msg.textContent='One or more stops can’t be located – please edit.'; if(flatMsg) flatMsg.textContent=msg.textContent;return;}
  const locs=rows.map(r=>({lat:+r.querySelector('.stop').dataset.lat,lng:+r.querySelector('.stop').dataset.lng}));
  return new Promise(resolve=>{
    dirSvc.route({
      origin:locs[0],destination:locs[locs.length-1],
      waypoints:locs.slice(1,-1).map(l=>({location:l,stopover:true})),
      travelMode:'DRIVING'
    },(res,stat)=>{
      displayLegs(res,stat);
      if(stat==='OK'){
        const pts=[locs[0],...locs.slice(1,-1),locs[locs.length-1]];
        drawRouteMarkers(pts,rows);
      }
      resolve();
    });
  });
}
function displayLegs(res,stat){
  const msg=document.getElementById('msg'), flatMsg=document.getElementById('flatMsg');
  if(stat!=='OK'){msg.textContent='Route error: '+stat; if(flatMsg) flatMsg.textContent=msg.textContent; clearDirections();return;}
  dirRend.setDirections(res);

  // >>>>> NEW: auto-focus map on the current route (with sensible padding)
  const b = res?.routes?.[0]?.bounds;
  if (b && map){
    // leave space for your left panel / flat bar
    const leftPad = (flatMode ?  (document.getElementById('panel')?.offsetWidth||480)+24 : 24);
    map.fitBounds(b, { top: 60, right: 28, bottom: (flatMode? 160: 60), left: leftPad });
  }
  // <<<<< end insert

  const rows=getOrderedRows();

  let kmTot=0,minTot=0;clearLegDisplays();
  res.routes[0].legs.forEach((leg,i)=>{
    const km=leg.distance.value/1000,min=Math.round(leg.duration.value/60);
    kmTot+=km;minTot+=min;
    const startLetter=rows[i]?.querySelector('.bullet')?.textContent.trim()||'';
    const cls=['A','B','C','D','E','F','G','H'].includes(startLetter)?('leg-'+startLetter):'leg-default';
    const div=document.createElement('div');div.className='leg-display '+cls;
    div.textContent=`Distance ${km.toFixed(1)} km | ≈ ${min} min`;
    rows[i].after(div);
  });
  const text=`Total Distance ${kmTot.toFixed(1)} km | ≈ ${minTot} min`;
  msg.textContent=text; if(flatMsg) flatMsg.textContent=text;
}
function clearLegDisplays(){document.querySelectorAll('.leg-display').forEach(d=>d.remove());}

/* =================== DRIVING DISTANCE MATRIX (exact) =================== */
async function buildDrivingMatrixAll(points){
  // Build full NxN driving-distance matrix using Google DistanceMatrixService, chunked.
  const n = points.length;
  const D = Array.from({length:n},()=>Array(n).fill(0));
  const MAX = 25; // API limit per call dimension

  async function getBlock(oStart, oEnd, dStart, dEnd){
    return new Promise((resolve)=>{
      dmSvc.getDistanceMatrix({
        origins: points.slice(oStart,oEnd),
        destinations: points.slice(dStart,dEnd),
        travelMode: google.maps.TravelMode.DRIVING,
        unitSystem: google.maps.UnitSystem.METRIC
      }, (res, status)=>{
        if(status !== 'OK' || !res?.rows){
          // fallback: fill with haversine if API fails
          for(let i=oStart;i<oEnd;i++){
            for(let j=dStart;j<dEnd;j++){
              if(i===j){ D[i][j]=0; continue; }
              D[i][j] = haversine(points[i], points[j]);
            }
          }
          resolve();
          return;
        }
        for(let i=oStart;i<oEnd;i++){
          const row = res.rows[i - oStart];
          for(let j=dStart;j<dEnd;j++){
            const el = row.elements[j - dStart];
            if(i===j){ D[i][j]=0; continue; }
            if(el?.status === 'OK'){
              D[i][j] = (el.distance.value || 0) / 1000; // km
            }else{
              D[i][j] = haversine(points[i], points[j]); // fallback
            }
          }
        }
        resolve();
      });
    });
  }

  for(let oi=0; oi<n; oi+=MAX){
    for(let dj=0; dj<n; dj+=MAX){
      await getBlock(oi, Math.min(oi+MAX,n), dj, Math.min(dj+MAX,n));
    }
  }
  return D;
}
function haversine(a,b){const R=6371;const toRad=x=>x*Math.PI/180;const dLat=toRad(b.lat-a.lat);const dLng=toRad(b.lng-a.lng);const s=Math.sin(dLat/2)**2+Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*Math.sin(dLng/2)**2;return 2*R*Math.asin(Math.sqrt(s));}

/* =================== Held–Karp shortest Hamiltonian PATH (per frame) =================== */
function shortestHamiltonianPaths(D){
  // Returns {cost[s][t], path[s][t]} minimal path visiting all vertices exactly once, from s to t.
  const n = D.length;
  const INF = 1e18;
  const cost = Array.from({length:n},()=>Array(n).fill(INF));
  const path = Array.from({length:n},()=>Array(n).fill(null));

  if(n===0) return {cost, path};
  if(n===1){
    cost[0][0]=0; path[0][0]=[0];
    return {cost, path};
  }

  for(let s=0;s<n;s++){
    const FULL = (1<<n);
    const dp   = Array.from({length:FULL},()=>Array(n).fill(INF));
    const prev = Array.from({length:FULL},()=>Array(n).fill(-1));
    dp[1<<s][s] = 0;

    for(let mask=0; mask<FULL; mask++){
      if((mask & (1<<s)) === 0) continue;             // must include start
      for(let v=0; v<n; v++){
        if(!(mask & (1<<v))) continue;                 // v must be in mask
        const dv = dp[mask][v];
        if(dv >= INF) continue;
        for(let w=0; w<n; w++){
          if(mask & (1<<w)) continue;                  // next not yet in mask
          const nm = mask | (1<<w);
          const cand = dv + D[v][w];
          if(cand < dp[nm][w]){
            dp[nm][w] = cand;
            prev[nm][w] = v;
          }
        }
      }
    }

    const ALL = (1<<n)-1;
    for(let t=0;t<n;t++){
      if(t===s && n>1) continue; // for n>1, s==t would imply a cycle; skip
      const c = dp[ALL][t];
      if(c < cost[s][t]){
        cost[s][t] = c;
        // reconstruct
        const seq = [];
        let mask = ALL, cur = t;
        while(cur !== -1){
          seq.push(cur);
          const p = prev[mask][cur];
          if(p === -1) break;
          mask ^= (1<<cur);
          cur = p;
        }
        seq.reverse(); // from s..t
        path[s][t] = seq;
      }
    }
  }
  return {cost, path};
}
/* =================== CONSECUTIVE DUPLICATE REMOVAL (coords-first) =================== */
// Suffix map to normalize St/Street, Rd/Road, etc. for text fallback
const SUFFIX_MAP = {
  'street':'st', 'st':'st',
  'avenue':'ave', 'ave':'ave',
  'road':'rd', 'rd':'rd',
  'drive':'dr', 'dr':'dr',
  'lane':'ln', 'ln':'ln',
  'court':'ct', 'ct':'ct',
  'place':'pl', 'pl':'pl',
  'boulevard':'blvd', 'blvd':'blvd',
  'highway':'hwy', 'hwy':'hwy',
  'crescent':'cres', 'cres':'cres',
  'terrace':'ter', 'ter':'ter',
  'parkway':'pkwy', 'pkwy':'pkwy'
};

// very tolerant text normalizer (used only if we don't have coords)
function normForCompare(addr){
  let t = (addr||'')
    .toLowerCase()
    .replace(/[,\.;:]+$/,'')                 // strip trailing punctuation
    .replace(/\b(canada|british columbia|bc)\b/g,'')  // remove country/province
    .replace(/\b[a-z]\d[a-z]\s?\d[a-z]\d\b/gi,'')     // remove postal code
    .replace(/^\s*(?:#\s*\d+[a-z]?|(?:unit|suite|apt|apartment)\s*\d+[a-z]?)\s*[-–]?\s*/i,'') // drop unit/suite
    .replace(/\s+/g,' ')
    .trim();

  // normalize common street suffixes
  t = t.replace(/\b(street|st|avenue|ave|road|rd|drive|dr|lane|ln|court|ct|place|pl|boulevard|blvd|highway|hwy|crescent|cres|terrace|ter|parkway|pkwy)\b/g,
      (m)=>SUFFIX_MAP[m]||m);
  return t;
}

// distance-based equality if both rows already have coords
function rowsSamePlace(r1, r2){
  const a = r1?.querySelector('.stop'), b = r2?.querySelector('.stop');
  if(!a || !b) return false;

  const haveA = a.dataset.lat && a.dataset.lng;
  const haveB = b.dataset.lat && b.dataset.lng;

  if (haveA && haveB){
    const p = {lat:+a.dataset.lat, lng:+a.dataset.lng};
    const q = {lat:+b.dataset.lat, lng:+b.dataset.lng};
    // treat as identical if within 30m
    return haversine(p,q) < 0.03;
  }
  // fallback to text compare
  return normForCompare(a.value) === normForCompare(b.value);
}

// Ensure coords for visible rows, then remove only adjacent duplicates
async function collapseConsecutiveDuplicatesCurrentView(){
  const rows = window.flatMode
    ? [...document.querySelectorAll('#addrList .row')]
    : FRAMES.flatMap(fr=>{
        const sec = document.querySelector(`.frame[data-frame="${fr.id}"]`);
        const vis = (fr.shift==='day' && dayVisible) || (fr.shift==='night' && nightVisible);
        if (!vis || sec.classList.contains('collapsed') || sec.style.display==='none') return [];
        return [...document.querySelectorAll(`#frame-${fr.id} .row`)];
      });

  // 1) Ensure coordinates (helps us compare by location, not formatting)
  await ensureCoords(rows, {parallel:true});

  // 2) Walk from the end removing only the *immediately next* duplicate
  for (let i = rows.length - 2; i >= 0; i--){
    if (rowsSamePlace(rows[i], rows[i+1])){
      rows[i+1].remove();
    }
  }
}

/* =================== PRUNE EMPTY ROWS & FRAMES (after optimize) =================== */
function pruneEmptyRowsAndFrames(){
  if (flatMode){
    const list = document.getElementById('addrList');
    [...list.querySelectorAll('.row')].forEach(r=>{
      const v=(r.querySelector('.stop').value||'').trim();
      if(!v) r.remove();
    });
    renumber();
    return;
  }
  // In framed view: remove empties; collapse frames with no rows left
  FRAMES.forEach(fr=>{
    const sec=document.querySelector(`.frame[data-frame="${fr.id}"]`);
    const visible=(fr.shift==='day'&&dayVisible)||(fr.shift==='night'&&nightVisible);
    if(!visible || sec.style.display==='none') return;
    const list=document.getElementById('frame-'+fr.id);
    [...list.querySelectorAll('.row')].forEach(r=>{
      const v=(r.querySelector('.stop').value||'').trim();
      if(!v) r.remove();
    });
    const any=list.querySelector('.row');
    setFrameCollapsed(fr.id, !any); // collapse if now empty
  });
  renumber();
  scheduleTimelineBuild();
}

/* =================== OPTIMIZE BY FRAMES (exact with DP across frames) =================== */
async function optimizeByFrames(){
  if (flatMode){ return; }

  // collect visible (and not collapsed) frames in order
  const activeFrames = FRAMES.filter(fr=>{
    const visible=(fr.shift==='day'&&dayVisible)||(fr.shift==='night'&&nightVisible);
    const sec=document.querySelector(`.frame[data-frame="${fr.id}"]`);
    return visible && sec && !sec.classList.contains('collapsed') && sec.style.display!=='none';
  });

  // rows per frame + ensure coords
  const perFrame = activeFrames.map(fr=>{
    const list = document.getElementById('frame-'+fr.id);
    const rows = [...list.querySelectorAll('.row')].filter(r=>r.querySelector('.stop').value.trim());
    return {fr, rows};
  });
  const allRows = perFrame.flatMap(x=>x.rows);
  if(allRows.length<=1){ pruneEmptyRowsAndFrames(); renumber(); scheduleAutoCompute(0,true); return; }

  const ok = await ensureCoords(allRows,{parallel:true});
  if(!ok){ document.getElementById('msg').textContent='One or more stops can’t be located – please edit.'; return; }

  // Gather all points and map to global indices
  const allPoints = [];
  perFrame.forEach((pf)=>{
    pf.globalIdxs = [];
    pf.rows.forEach(r=>{
      const p = {lat:+r.querySelector('.stop').dataset.lat, lng:+r.querySelector('.stop').dataset.lng};
      pf.globalIdxs.push(allPoints.length);
      allPoints.push(p);
    });
  });

  // Build global driving matrix once (exact)
  const Dglobal = await buildDrivingMatrixAll(allPoints);

  // ----- lock-respecting in-frame ordering -----
  function orderFrameWithLocks(pf){
    const idxs = pf.globalIdxs.slice(); // global indices for this frame in current order
    const locked = pf.rows.map((r,i)=>isLocked(r)?i:-1).filter(i=>i>=0);
    if(locked.length===0){
      // leave unlocked; Held–Karp will handle via candidates below
      return null; // means "no forced order"
    }

    // Build a new local order that respects locked anchors
    const finalLocal = [];
    const m = idxs.length;

    function Dloc(i,j){ return Dglobal[idxs[i]][idxs[j]]; }

    function optimizeRun(lo,hi,leftAnchorIdx,rightAnchorIdx){
      const sub = [];
      for(let k=lo;k<=hi;k++) sub.push(k);
      if(sub.length<=1) return sub;

      // local matrix for run
      const u = sub.length;
      const Dblock = Array.from({length:u},()=>Array(u).fill(0));
      for(let a=0;a<u;a++){
        for(let b=0;b<u;b++){
          if(a===b) Dblock[a][b]=0; else Dblock[a][b]=Dloc(sub[a],sub[b]);
        }
      }
      const hk = shortestHamiltonianPaths(Dblock);

      // convert possible anchors into local indices
      const Lg = leftAnchorIdx, Rg = rightAnchorIdx; // local indices are sub[*] holders

      if(Lg!=null && Rg!=null){
        let best=1e18, bestS=0, bestT=u-1, bestPath=null;
        for(let s=0;s<u;s++){
          for(let t=0;t<u;t++){
            if(u>1 && s===t) continue;
            const inner = hk.cost[s][t];
            if(!Number.isFinite(inner)) continue;
            const tot = Dloc(Lg, sub[s]) + inner + Dloc(sub[t], Rg);
            if(tot<best){ best=tot; bestS=s; bestT=t; bestPath=hk.path[s][t]; }
          }
        }
        return (bestPath||[...Array(u).keys()]).map(k=>sub[k]);
      }
      if(Lg!=null && Rg==null){
        let best=1e18, bestS=0, bestT=u-1, bestPath=null;
        for(let s=0;s<u;s++){
          for(let t=0;t<u;t++){
            if(u>1 && s===t) continue;
            const inner = hk.cost[s][t];
            if(!Number.isFinite(inner)) continue;
            const tot = Dloc(Lg, sub[s]) + inner;
            if(tot<best){ best=tot; bestS=s; bestT=t; bestPath=hk.path[s][t]; }
          }
        }
        return (bestPath||[...Array(u).keys()]).map(k=>sub[k]);
      }
      if(Lg==null && Rg!=null){
        let best=1e18, bestS=0, bestT=u-1, bestPath=null;
        for(let s=0;s<u;s++){
          for(let t=0;t<u;t++){
            if(u>1 && s===t) continue;
            const inner = hk.cost[s][t];
            if(!Number.isFinite(inner)) continue;
            const tot = inner + Dloc(sub[t], Rg);
            if(tot<best){ best=tot; bestS=s; bestT=t; bestPath=hk.path[s][t]; }
          }
        }
        return (bestPath||[...Array(u).keys()]).map(k=>sub[k]);
      }
      // no anchors; just best path
      let best=1e18, bestS=0, bestT=u-1, bestPath=null;
      for(let s=0;s<u;s++){
        for(let t=0;t<u;t++){
          if(u>1 && s===t) continue;
          const inner = hk.cost[s][t];
          if(!Number.isFinite(inner)) continue;
          if(inner<best){ best=inner; bestS=s; bestT=t; bestPath=hk.path[s][t]; }
        }
      }
      return (bestPath||[...Array(u).keys()]).map(k=>sub[k]);
    }

    const lockedSet = new Set(locked);
    let i=0;
    while(i<m){
      if(lockedSet.has(i)){ finalLocal.push(i); i++; continue; }
      const lo=i; while(i<m && !lockedSet.has(i)) i++; const hi=i-1;
      const leftA  = (lo-1>=0 && lockedSet.has(lo-1)) ? (lo-1) : null;
      const rightA = (hi+1<m && lockedSet.has(hi+1)) ? (hi+1) : null;
      finalLocal.push(...optimizeRun(lo,hi,leftA,rightA));
    }
    return finalLocal; // array of local indices 0..m-1 in new order (locks included)
  }

  // If a frame has locks, fix its internal order now; otherwise leave it for candidates below
  perFrame.forEach(pf=>{
    const ord = orderFrameWithLocks(pf);
    if(Array.isArray(ord)){
      // apply order to pf.rows and pf.globalIdxs
      pf.rows = ord.map(i=>pf.rows[i]);
      pf.globalIdxs = ord.map(i=>pf.globalIdxs[i]);
    }
  });

  // Build candidate tables per frame (as before) using HK on the (possibly pre-ordered) frame
  const framesPlan = perFrame.map(pf=>{
    const n = pf.rows.length;
    if(n===0){
      return { ...pf, n, candidates:[{s:null,t:null,order:[],cost:0}] };
    }
    if(n===1){
      return { ...pf, n, candidates:[{s:0,t:0,order:[0],cost:0}] };
    }
    const idxs = pf.globalIdxs;
    const D = Array.from({length:n},()=>Array(n).fill(0));
    for(let i=0;i<n;i++){
      for(let j=0;j<n;j++){
        D[i][j] = (i===j)?0 : Dglobal[idxs[i]][idxs[j]];
      }
    }

    // If the frame had locks we already arranged pf.rows. To keep those positions fixed,
    // we offer only the single "ordered" candidate; otherwise, enumerate all s,t like before.
    const hadLocks = pf.rows.some((r)=>isLocked(r));
    if(hadLocks){
      return { ...pf, n, candidates:[{s:0, t:n-1, order:[...Array(n).keys()], cost: (()=> {
        let c=0; for(let i=0;i<n-1;i++) c+=D[i][i+1]; return c;
      })()}] };
    }

    const hk = shortestHamiltonianPaths(D);
    const cands = [];
    for(let s=0;s<n;s++){
      for(let t=0;t<n;t++){
        if(s===t && n>1) continue;
        const c = hk.cost[s][t];
        const o = hk.path[s][t];
        if(Number.isFinite(c) && o && o.length===n){
          cands.push({s,t,order:o.slice(),cost:c});
        }
      }
    }
    return { ...pf, n, candidates: cands, idxs };
  });

  // DP across frames (unchanged)
  function linkCost(prevPlan, prevCand, nextPlan, nextCand){
    if(prevCand.t==null || nextCand.s==null) return 0;
    const gi = prevPlan.globalIdxs[prevCand.t];
    const gj = nextPlan.globalIdxs[nextCand.s];
    return Dglobal[gi][gj];
  }

  const N = framesPlan.length;
  const dp = []; const back = [];
  for(let k=0;k<N;k++){
    dp[k] = Array(framesPlan[k].candidates.length).fill(Infinity);
    back[k] = Array(framesPlan[k].candidates.length).fill(-1);
    if(k===0){
      for(let j=0;j<dp[k].length;j++){
        dp[k][j] = framesPlan[k].candidates[j].cost;
      }
    }else{
      for(let j=0;j<dp[k].length;j++){
        const curC = framesPlan[k].candidates[j];
        let best=Infinity, bestP=-1;
        for(let p=0;p<dp[k-1].length;p++){
          const prevC = framesPlan[k-1].candidates[p];
          const tot = dp[k-1][p] + linkCost(framesPlan[k-1], prevC, framesPlan[k], curC) + curC.cost;
          if(tot < best){ best=tot; bestP=p; }
        }
        dp[k][j]=best; back[k][j]=bestP;
      }
    }
  }
  // Backtrack best sequence
  let lastIdx = 0, best=Infinity;
  for(let j=0;j<dp[N-1].length;j++){ if(dp[N-1][j] < best){ best=dp[N-1][j]; lastIdx=j; } }
  const pick = Array(N).fill(0);
  for(let k=N-1;k>=0;k--){ pick[k]=lastIdx; lastIdx = back[k][lastIdx]; }

  // Apply reorders per frame
  for(let k=0;k<N;k++){
    const plan = framesPlan[k];
    const cand = plan.candidates[pick[k]];
    if(!cand || !cand.order || cand.order.length<=1) continue;
    const list = document.getElementById('frame-'+plan.fr.id);
    const orderedRows = cand.order.map(i=>plan.rows[i]);
    orderedRows.forEach(r=>list.appendChild(r));
  }

  pruneEmptyRowsAndFrames();
  renumber();
  scheduleAutoCompute(0,true);
}

/* Optional helpers kept (polygons etc.) */
const ALL_FEATURES = [];
const POLY_STORAGE_KEY = 'geoPolyState_v2';
let POLY_STATE = {};
let GROUP_STATE = {};
let dataAttached = true, deferWhileInteract = false, reattachTO = 0;

function areaCodeFromFeature(feat){
  const fields = ['code','Code','CODE','name','Name','NAME','title','Title','TITLE','description','Description'];
  let txt = '';
  fields.forEach(k => { const v = feat.getProperty && feat.getProperty(k); if(v) txt += ' ' + String(v); });
  try{ const id = feat.getId && feat.getId(); if(id) txt += ' ' + id; }catch(_){}
  txt = txt.toUpperCase();
  for(const code of Object.keys(AREA_COLORS)){ if(txt.includes(code)) return code; }
  return null;
}

function styleFeature(feature){
  // --- LIVE FEATURES (from events.js) ---
  if (feature.getProperty('__live')) {
    let t = '';
    try { t = feature.getGeometry()?.getType?.() || ''; } catch(_){}
    if (t.includes('Polygon')) {
      return feature.getProperty('__polyStyle') || { fillColor:'#E64A19', fillOpacity:.26, strokeColor:'#BF360C', strokeWeight:1.2 };
    }
    if (t.includes('LineString')) {
      return feature.getProperty('__lineStyle') || { strokeColor:'#F50057', strokeWeight:3, strokeOpacity:.9 };
    }
    if (t === 'Point') {
      return { icon: feature.getProperty('__pointIcon') || {
        path:'M0,-10 L10,0 L0,10 L-10,0 Z',
        fillColor:'#F50057', fillOpacity:1, strokeColor:'#fff', strokeWeight:1.5, scale:1
      }};
    }
    // default visible if live but no known geometry
    return { visible:true };
  }

  // --- NORMAL POLYGONS (your geo areas) ---
  if (feature.getProperty('__visible') === false) return {visible:false};
  const color  = feature.getProperty('__color') || '#607d8b';
  const stroke = feature.getProperty('__stroke') ?? AREA_STROKE_WEIGHT;
  const fillOp = feature.getProperty('__fillOpacity') ??
                 (feature.getProperty('__code')==='MISS2' ? Math.min(AREA_FILL_OPACITY, 0.12) : AREA_FILL_OPACITY);

  return {
    fillColor: color, fillOpacity: fillOp,
    strokeColor: color, strokeOpacity: 0.85,
    strokeWeight: stroke, visible:true
  };
}
window.styleFeature = styleFeature;     // keep this
styleFeature.__isBaseStyle = true;      // harmless tag; safe to keep
  
/* --- persistence --- */
function loadSaved(key, fallback){ try{ const v = JSON.parse(localStorage.getItem(key)||'null'); return v && typeof v==='object' ? v : fallback; }catch(_){ return fallback; } }
function saveSaved(key, obj){ try{ localStorage.setItem(key, JSON.stringify(obj)); }catch(_){ } }

/* helpers */
function getFeaturesByCode(code){ return ALL_FEATURES.filter(f => (f.getProperty('__code')||'') === code); }

async function loadGeoLayers(){
  map.data.setStyle(styleFeature);
  const savedPolys  = loadSaved(POLY_STORAGE_KEY, {});
  const savedGroups = loadSaved(GROUP_STORAGE_KEY, {});

  for (const layer of LAYERS){
    try{
      const res = await fetch(encodeURI(layer.file));
      if(!res.ok) throw new Error(res.statusText);
      const gj  = await res.json();
      const feats = map.data.addGeoJson(gj);
      feats.forEach(f=>{
        const code = areaCodeFromFeature(f);
        const fallbackName = f.getProperty('name') || f.getProperty('Name') || code || '';
        const savedRow = code ? savedPolys[code] : null;

        f.setProperty('__layer', layer.id);
        f.setProperty('__code', code);
        f.setProperty('__name', savedRow?.name || fallbackName);
        f.setProperty('__color', (savedRow?.color) || (code && AREA_COLORS[code] ? AREA_COLORS[code] : '#607d8b'));
        f.setProperty('__fillOpacity', AREA_FILL_OPACITY);
        f.setProperty('__stroke', AREA_STROKE_WEIGHT);

        const vis = savedRow?.visible !== false;
        f.setProperty('__visible', vis);

        ALL_FEATURES.push(f);
      });
    }catch(err){
      console.warn('GeoJSON load failed for', layer.file, err);
    }
  }

  // unique codes actually present
  const codes = [...new Set(ALL_FEATURES.map(f=>f.getProperty('__code')).filter(Boolean))].sort();
  POLY_STATE = {};
  codes.forEach(code=>{
    const any = ALL_FEATURES.find(f=>f.getProperty('__code')===code);
    POLY_STATE[code] = {
      visible: any?.getProperty('__visible') !== false,
      name:    any?.getProperty('__name') || code,
      color:   any?.getProperty('__color') || AREA_COLORS[code] || '#607d8b'
    };
  });
  saveSaved(POLY_STORAGE_KEY, POLY_STATE);

  // groups: start with definitions, then apply saved names/expansion
  GROUP_STATE = {};
  Object.keys(GROUP_DEFS).forEach(k=>{
    GROUP_STATE[k] = {
      name: savedGroups?.[k]?.name || GROUP_DEFS[k].name,
      expanded: savedGroups?.[k]?.expanded !== false
    };
  });
  saveSaved(GROUP_STORAGE_KEY, GROUP_STATE);

  buildDrawerUI();
  applyVisibility();
}

/* visibility + filter (groups + rows) */
function applyVisibility(){
  const qRaw = (document.getElementById('filterText')?.value || '').trim();
  const q = qRaw.toUpperCase();

  ALL_FEATURES.forEach(f=>{
    const code = (f.getProperty('__code') || '').toUpperCase();
    const name = (f.getProperty('__name') || '').toUpperCase();
    const st   = POLY_STATE[f.getProperty('__code')] || {visible:true};
    const match = !q || code.includes(q) || name.includes(q);
    const vis   = !!st.visible && match;
    f.setProperty('__visible', vis);
  });
  map.data.setStyle(styleFeature);

  const root = document.getElementById('groupsRoot');
  if(!root) return;
  [...root.querySelectorAll('.group')].forEach(g=>{
    const gkey = g.dataset.group;
    const gName = (GROUP_STATE[gkey]?.name || '').toUpperCase();
    const rows  = [...g.querySelectorAll('.poly-row')];

    let anyRowMatch = false;
    rows.forEach(r=>{
      const code = r.dataset.code;
      const nm = (POLY_STATE[code]?.name || code).toUpperCase();
      const match = !q || code.toUpperCase().includes(q) || nm.includes(q);
      r.style.display = match ? '' : 'none';
      if(match) anyRowMatch = true;
    });

    const groupMatches = !q || gName.includes(q) || anyRowMatch;
    g.style.display = groupMatches ? '' : 'none';

    if(q && gName.includes(q) && !anyRowMatch){
      rows.forEach(r=> r.style.display='');
    }
  });
}

/* Drawer UI with groups (accent colors applied) */
const GROUP_ACCENTS = {
  kel_central:'#3B82F6',  // blue
  kel_south:'#6B8E23',    // olive
  rut_lc:'#2A9D8F',       // teal
  west_kel:'#9C27B0'      // purple
};

function buildDrawerUI(){
  const btn = document.getElementById('areasBtn');
  const drawer = document.getElementById('areasDrawer');
  const closeBtn = document.getElementById('drawerClose');
  const setOpen = (open) => {
    drawer.classList.toggle('open', open);
    drawer.setAttribute('aria-hidden', open ? 'false':'true');
    btn.classList.toggle('open', open);
  };
  btn.onclick = ()=> setOpen(!drawer.classList.contains('open'));
  closeBtn.onclick = ()=> setOpen(false);

  const root = document.getElementById('groupsRoot');
  root.innerHTML = '';

  Object.keys(GROUP_DEFS).forEach(gkey=>{
    const gWrap = document.createElement('div');
    gWrap.className = 'group' + (GROUP_STATE[gkey]?.expanded===false ? ' collapsed':'');
    gWrap.dataset.group = gkey;
    gWrap.style.setProperty('--accent', GROUP_ACCENTS[gkey] || '#3B82F6');

    const gHead = document.createElement('div');
    gHead.className = 'group-header';
    gHead.innerHTML = `
      <button class="toggle" type="button" title="Expand/Collapse">
        <span class="material-icons">expand_more</span>
      </button>
      <input type="text" class="gname" value="${(GROUP_STATE[gkey]?.name||GROUP_DEFS[gkey].name).replace(/"/g,'&quot;')}" spellcheck="false">
    `;

    const gBody = document.createElement('div');
    gBody.className = 'group-body';

    GROUP_DEFS[gkey].codes
      .filter(code => code in POLY_STATE)
      .forEach(code => gBody.appendChild(makePolyRow(code)));

    gWrap.appendChild(gHead);
    gWrap.appendChild(gBody);
    root.appendChild(gWrap);

    gHead.querySelector('.toggle').addEventListener('click', ()=>{
      const now = !gWrap.classList.contains('collapsed');
      gWrap.classList.toggle('collapsed', now);
      GROUP_STATE[gkey].expanded = !now;
      saveSaved(GROUP_STORAGE_KEY, GROUP_STATE);
    });
    const nameInp = gHead.querySelector('.gname');
    nameInp.addEventListener('input', debounce(()=>{
      GROUP_STATE[gkey].name = (nameInp.value||'').trim() || GROUP_DEFS[gkey].name;
      saveSaved(GROUP_STORAGE_KEY, GROUP_STATE);
      applyVisibility();
    }, 120));
  });

  const op = document.getElementById('opacityRange');
  const opV= document.getElementById('opacityVal');
  const st = document.getElementById('strokeRange');
  const stV= document.getElementById('strokeVal');
  if(op){ op.value = AREA_FILL_OPACITY; opV.textContent = (+op.value).toFixed(2); }
  if(st){ st.value = AREA_STROKE_WEIGHT; stV.textContent = (+st.value).toFixed(1); }

  op?.addEventListener('input', ()=>{
    AREA_FILL_OPACITY = +op.value;
    opV.textContent = (+op.value).toFixed(2);
    ALL_FEATURES.forEach(f=>f.setProperty('__fillOpacity', AREA_FILL_OPACITY));
    map.data.setStyle(styleFeature);
  });
  st?.addEventListener('input', ()=>{
    AREA_STROKE_WEIGHT = +st.value;
    stV.textContent = (+st.value).toFixed(1);
    ALL_FEATURES.forEach(f=>f.setProperty('__stroke', AREA_STROKE_WEIGHT));
    map.data.setStyle(styleFeature);
  });

  const ft = document.getElementById('filterText');
  document.getElementById('filterClear').onclick=()=>{ ft.value=''; applyVisibility(); };
  ft.addEventListener('input', debounce(applyVisibility, 80));
}

/* create one polygon row */
function makePolyRow(code){
  const st = POLY_STATE[code];
  const row = document.createElement('div');
  row.className='poly-row';
  row.dataset.code = code;

  const ckWrap = document.createElement('div');
  ckWrap.className = 'ck';
  ckWrap.innerHTML = `<input type="checkbox" ${st.visible?'checked':''} aria-label="Toggle ${st.name}">`;

  const nameWrap = document.createElement('div');
  nameWrap.className = 'name';
  const nameInput = document.createElement('input');
  nameInput.type = 'text';
  nameInput.value = st.name || code;
  nameInput.placeholder = code;
  nameInput.spellcheck = false;
  nameInput.setAttribute('data-code', code);
  nameWrap.appendChild(nameInput);

  const swatch = document.createElement('button');
  swatch.className = 'swatch';
  swatch.title = `Change color for ${st.name || code}`;
  swatch.style.background = st.color;
  const colorInput = document.createElement('input');
  colorInput.type = 'color';
  colorInput.value = st.color;
  colorInput.setAttribute('data-code', code);

  row.appendChild(ckWrap);
  row.appendChild(nameWrap);
  row.appendChild(swatch);
  row.appendChild(colorInput);

  ckWrap.querySelector('input').addEventListener('change', (e)=>{
    POLY_STATE[code].visible = !!e.target.checked; saveSaved(POLY_STORAGE_KEY, POLY_STATE);
    getFeaturesByCode(code).forEach(f=> f.setProperty('__visible', POLY_STATE[code].visible));
    applyVisibility();
  });

  nameInput.addEventListener('input', debounce(()=>{
    POLY_STATE[code].name = (nameInput.value||'').trim() || code; saveSaved(POLY_STORAGE_KEY, POLY_STATE);
    getFeaturesByCode(code).forEach(f=> f.setProperty('__name', POLY_STATE[code].name));
    applyVisibility();
  }, 120));

  swatch.addEventListener('click', ()=> colorInput.click());
  colorInput.addEventListener('input', ()=>{
    const hex = colorInput.value;
    POLY_STATE[code].color = hex; saveSaved(POLY_STORAGE_KEY, POLY_STATE);
    swatch.style.background = hex;
    getFeaturesByCode(code).forEach(f=> f.setProperty('__color', hex));
    map.data.setStyle(styleFeature);
  });

  return row;
}

function detachData(){
  if(!deferWhileInteract || !dataAttached) return;
  map.data.setMap(null); dataAttached=false;
}
function reattachData(){
  if(dataAttached) return;
  map.data.setMap(map); dataAttached=true;
}

/* ============ F1..F4 keyboard shortcuts ============ */
function initHotkeys(){
  document.addEventListener('keydown', (e)=>{
    if (e.altKey || e.ctrlKey || e.metaKey) return;

    switch (e.key) {
      case 'F1': {                           // Toggle Day
        e.preventDefault();
        toggleShift('day');
        break;
      }
      case 'F2': {                           // Toggle Night
        e.preventDefault();
        toggleShift('night');
        break;
      }
      case 'F3': {                           // Clear filled address bars in CURRENT VIEW
        e.preventDefault();
        clearFilledCurrentView();
        break;
      }
case 'F4': {                           // Optimize (by Frames in framed view, global in flat view)
  e.preventDefault();
  autoResolveNext = true;
  collapseConsecutiveDuplicatesCurrentView().then(()=>{
    if (flatMode) {
      globalOptimizeRoute();
    } else {
      optimizeByFrames();
    }
  });
  break;
}
      default: return;
    }
  }, true);
}
/* ============================================================================ */

/* =================== INIT =================== */
window.routePlannerInit=()=>{
  map=new google.maps.Map(document.getElementById('map'),{
    center:{lat:49.8879,lng:-119.4960}, zoom:10,
    mapTypeControl:false,streetViewControl:true,fullscreenControl:true,tilt:0
  });
  window.map = map; 
  
  // Provide the overlay class after Maps loads
  initRegionLabelOverlay();

  OK_BOUNDS = new google.maps.LatLngBounds(
    new google.maps.LatLng(49.60,-119.80),
    new google.maps.LatLng(50.20,-119.15)
  );

  /* ---------- GeoJSON areas + label toggle ---------- */
  let currentRegionOverlay=null;
  let currentRegionId=null;

  function showRegionLabel(pos,name,id){
    hideRegionLabel();
    currentRegionOverlay=new RegionLabelOverlay(pos,name,pickAccentFromName(name||''));
    currentRegionId=id || name || '';
    currentRegionOverlay.setMap(map);
  }
  function hideRegionLabel(){
    if(currentRegionOverlay){ currentRegionOverlay.setMap(null); }
    currentRegionOverlay=null; currentRegionId=null;
  }

  loadGeoLayers(); // async; builds drawer UI after load

  map.data.addListener('click', (e)=>{
    const name = e.feature.getProperty('__name') || e.feature.getProperty('name') || 'Region';
    const id   = (e.feature.getId && e.feature.getId()) || name;
    if(currentRegionOverlay && currentRegionId===id){ hideRegionLabel(); return; }
    const pos  = e.latLng || map.getCenter();
    showRegionLabel(pos, name, id);
  });
  map.addListener('click', hideRegionLabel);
  document.getElementById('panel').addEventListener('click', hideRegionLabel, true);

  /* ---------- Services ---------- */
  dirSvc=new google.maps.DirectionsService();
  dirRend=new google.maps.DirectionsRenderer({map,suppressMarkers:true});
  geocoder=new google.maps.Geocoder();
  acService=new google.maps.places.AutocompleteService();
  placeSvc=new google.maps.places.PlacesService(map);
  dmSvc = new google.maps.DistanceMatrixService();
  initHomeBasePins();

  buildFrameBuckets();
  buildAddrBar();

  applyShiftVisibility();  // start in FLAT

 document.getElementById('flatOpt').onclick=()=>{
  autoResolveNext = true;
  collapseConsecutiveDuplicatesCurrentView();   // << pre-opt
  globalOptimizeRoute();
};
  document.getElementById('flatDelSel').onclick=deleteSelected;

  const sv = map.getStreetView();
  sv.addListener('visible_changed', () => enforcePanelVisibility());
  enforcePanelVisibility();

  window.addEventListener('resize', ()=>{ clearTimeout(window.__rb); window.__rb=setTimeout(()=>{rebalanceFrameHeights();},150); });

  // bind hotkeys
  initHotkeys();
};

/* If Maps loaded before this script, init() already ran and set the flag. */
if (window.__mapsApiReady) { window.routePlannerInit(); }

/* --------- Flat-view optimizer (exact) --------- */
async function globalOptimizeRoute(){
  if(!flatMode){ return; }
  const list = document.getElementById('addrList');

  // Remove blanks first
  [...list.querySelectorAll('.row')].forEach(r=>{
    if(!r.querySelector('.stop').value.trim()) r.remove();
  });

  const rows = [...list.querySelectorAll('.row')].filter(r=>r.querySelector('.stop').value.trim());
  if(rows.length <= 1){ renumber(); scheduleAutoCompute(0,true); return; }

  const ok = await ensureCoords(rows,{parallel:true});
  if(!ok){ const fm=document.getElementById('flatMsg'); if(fm) fm.textContent='One or more stops can’t be located – please edit.'; return; }

  // Points in current order
  const pts = rows.map(r=>({lat:+r.querySelector('.stop').dataset.lat, lng:+r.querySelector('.stop').dataset.lng}));

  // Distance matrix (driving)
  const D = await buildDrivingMatrixAll(pts);

  // Split into segments separated by locked anchors
  const lockedIdxs = rows.map((r,i)=>isLocked(r)?i:-1).filter(i=>i>=0);

  // If nothing is locked, do your standard global HK route
  if(lockedIdxs.length === 0){
    const {cost, path} = shortestHamiltonianPaths(D);
    let bestC=1e18, bestS=0, bestT=rows.length-1;
    for(let s=0;s<rows.length;s++){
      for(let t=0;t<rows.length;t++){
        if(s===t && rows.length>1) continue;
        if(cost[s][t] < bestC){ bestC=cost[s][t]; bestS=s; bestT=t; }
      }
    }
    const ord = path[bestS][bestT] || [...rows.keys()];
    const ordered=ord.map(i=>rows[i]);
    ordered.forEach(r=>list.appendChild(r));
    pruneEmptyRowsAndFrames(); renumber(); scheduleAutoCompute(0,true); return;
  }

  // Build final order honoring locked anchors
  // Strategy: keep locked rows fixed in place; optimize each free run between anchors.
  const finalOrder = [];
  const n = rows.length;

  // Helper: optimize subarray [lo..hi] (inclusive) that contains only UNLOCKED rows,
  // with optional left/right anchors (indices into the global array) supplying link costs.
  function optimizeRun(lo, hi, leftAnchorIdx, rightAnchorIdx){
    const idxs = [];
    for(let i=lo;i<=hi;i++) idxs.push(i);
    if(idxs.length<=1){ return idxs; } // nothing to optimize

    // Build local Dblock
    const m = idxs.length;
    const Dblock = Array.from({length:m},()=>Array(m).fill(0));
    for(let i=0;i<m;i++){
      for(let j=0;j<m;j++){
        if(i===j) Dblock[i][j]=0; else Dblock[i][j]=D[idxs[i]][idxs[j]];
      }
    }
    const hk = shortestHamiltonianPaths(Dblock);

    // If both anchors exist, choose start/end that minimize link cost: L -> start -> ... -> end -> R
    if(leftAnchorIdx!=null && rightAnchorIdx!=null){
      let best=1e18, bestS=0, bestT=m-1, bestPath=null;
      for(let s=0;s<m;s++){
        for(let t=0;t<m;t++){
          if(m>1 && s===t) continue;
          const inner = hk.cost[s][t];
          if(!Number.isFinite(inner)) continue;
          const tot = D[leftAnchorIdx][idxs[s]] + inner + D[idxs[t]][rightAnchorIdx];
          if(tot < best){ best=tot; bestS=s; bestT=t; bestPath = hk.path[s][t]; }
        }
      }
      return (bestPath||[...Array(m).keys()]).map(k=>idxs[k]);
    }

    // Only left anchor: minimize L -> start -> ... (no forced end)
    if(leftAnchorIdx!=null && rightAnchorIdx==null){
      let best=1e18, bestS=0, bestT=m-1, bestPath=null;
      for(let s=0;s<m;s++){
        for(let t=0;t<m;t++){
          if(m>1 && s===t) continue;
          const inner = hk.cost[s][t];
          if(!Number.isFinite(inner)) continue;
          const tot = D[leftAnchorIdx][idxs[s]] + inner;
          if(tot < best){ best=tot; bestS=s; bestT=t; bestPath = hk.path[s][t]; }
        }
      }
      return (bestPath||[...Array(m).keys()]).map(k=>idxs[k]);
    }

    // Only right anchor: minimize ... -> end -> R
    if(leftAnchorIdx==null && rightAnchorIdx!=null){
      let best=1e18, bestS=0, bestT=m-1, bestPath=null;
      for(let s=0;s<m;s++){
        for(let t=0;t<m;t++){
          if(m>1 && s===t) continue;
          const inner = hk.cost[s][t];
          if(!Number.isFinite(inner)) continue;
          const tot = inner + D[idxs[t]][rightAnchorIdx];
          if(tot < best){ best=tot; bestS=s; bestT=t; bestPath = hk.path[s][t]; }
        }
      }
      return (bestPath||[...Array(m).keys()]).map(k=>idxs[k]);
    }

    // No anchors (should not happen between locks, but can be the whole list if all unlocked)
    let best=1e18, bestS=0, bestT=m-1, bestPath=null;
    for(let s=0;s<m;s++){
      for(let t=0;t<m;t++){
        if(m>1 && s===t) continue;
        const inner = hk.cost[s][t];
        if(!Number.isFinite(inner)) continue;
        if(inner < best){ best=inner; bestS=s; bestT=t; bestPath = hk.path[s][t]; }
      }
    }
    return (bestPath||[...Array(m).keys()]).map(k=>idxs[k]);
  }

  // Walk the list and collect runs
  const lockedSet = new Set(lockedIdxs);
  let i=0;
  while(i<n){
    if(lockedSet.has(i)){
      finalOrder.push(i); // keep locked in place
      i++;
      continue;
    }
    // start of a free run
    const lo = i;
    while(i<n && !lockedSet.has(i)) i++;
    const hi = i-1;
    const leftAnchor  = (lo-1>=0 && lockedSet.has(lo-1)) ? (lo-1) : null;
    const rightAnchor = (hi+1<n && lockedSet.has(hi+1)) ? (hi+1) : null;

    const bestIdxs = optimizeRun(lo, hi, leftAnchor, rightAnchor);
    finalOrder.push(...bestIdxs);
  }

  // Rebuild DOM in that order
  const orderedRows = finalOrder.map(k=>rows[k]);
  orderedRows.forEach(r=>list.appendChild(r));

  pruneEmptyRowsAndFrames();
  renumber();
  scheduleAutoCompute(0,true);
}
</script>

<script defer src="ocr-paste.js"></script>
<script defer src="events.js"></script>
</body>
</html>
